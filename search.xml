<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>搭建一款自己的备忘录memos</title>
      <link href="/post/c80308e7.html"/>
      <url>/post/c80308e7.html</url>
      
        <content type="html"><![CDATA[<h1 id="搭建一款自己的备忘录memos"><a href="#搭建一款自己的备忘录memos" class="headerlink" title="搭建一款自己的备忘录memos"></a>搭建一款自己的备忘录memos</h1><p>之前我都是使用浮墨笔记flomo来存自己的想法和一些碎碎念，但笔记是存在云端，总是不放心自己的数据，也担心泄露出去，所以后来就慢慢的用文件传输助手代替了它。</p><p><img src="https://image.nicebao.com/luntan/d5ba194afa3c30bcbab3e8c9f77041f9.webp" alt="image-20240111113257144"></p><p>直到今天，我发现了一款类似于flomo的笔记程序memos，可以理解为memos是flomo的开源版本，唯一的缺点就是想要接入微信公众号或微信程序员有些麻烦，但无伤大雅，使用手机APP也未尝不可。</p><h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><p>我这里使用宝塔来进行安装如图所示,宝塔版本为的8.05，若旧版可能界面不太一样</p><p><img src="https://image.nicebao.com/luntan/1cc4cfe9d5a7d2cfa2968b516d4bac49.webp" alt="image-20240111113750670"></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d --name memos -p 5230:5230 -v ~/.memos/:/var/opt/memos ghcr.io/usememos/memos:latest</span></span><br></pre></td></tr></table></figure><p>安装成功后会出现如下界面</p><p><img src="https://image.nicebao.com/luntan/cc0db14cf1845644d49ca52fbfc7442c.webp" alt="image-20240111113925422"></p><p>现在我们来配置反向代理，我不建议直接点击这里的反向代理，因为我使用这里的反代后会和php项目出现冲突，也许是我的个人现象。</p><p><img src="https://image.nicebao.com/luntan/a52680855c2c3b94f626d2649ae2a234.webp" alt="image-20240111114314234"></p><p>如图所示，在域名里输入你想要配置的域名</p><p>然后进行如下操作，按照图中配置填写即可，如果需要ssl证书，我们直接在这里配置ssl即可</p><p><img src="https://image.nicebao.com/luntan/deacae838f84aea04c885e65040ba288.webp" alt="image-20240111114432036"></p><p>这样我们就成功的安装好了memos</p><h2 id="配置memos"><a href="#配置memos" class="headerlink" title="配置memos"></a>配置memos</h2><p>第一次进入memos，会要求注册账号，注册的第一个账号就为管理员账号。</p><p>我们首先将语言设置为中文</p><p><img src="https://image.nicebao.com/luntan/d373a3f8544042aca9be0cb02fdbcc10.webp" alt="image-20240111114723703"></p><p>接下来配置对象存储，让我们发送的图片&#x2F;文件等都存在云端</p><blockquote><p>我最初使用的是国内服务器配置b2存储桶，发现报500错误，github找到了相同问题的朋友，说是回退到上一版本即可，发现还是不行，检查了半天都没查出错误。</p><p>最后我尝试移植到海外服务器，发现相同的配置，海外服务器就可以访问，太奇怪了。</p><p>最奇怪的是国内服务器也可以ping通b2，所以国内的朋友们如果b2无法访问可以尝试换成其他的对象存储，例如七牛云</p><p>我这里仍使用b2进行演示</p></blockquote><p><img src="https://image.nicebao.com/luntan/0f25936e251251952162cc6c62e1361d.webp" alt="image-20240111115658815"></p><p><img src="https://image.nicebao.com/luntan/4bfeb082021909eec342c301fdfcbb6c.webp" alt="image-20240111115029865"></p><p>我这里使用的是b2进行存储 <a href="https://secure.backblaze.com/">https://secure.backblaze.com/</a></p><p>我们首先来到b2创建一个存储桶，创建时一定要选择公共桶</p><p><img src="https://image.nicebao.com/luntan/fffdec491d262a67625d443bb3f6a940.webp" alt="image-20240111115153701"></p><p><img src="https://image.nicebao.com/luntan/3b9dc56661861436ae59c1a5a0eaad54.webp" alt="image-20240111115532591"></p><p>接下来我们创建一个密钥</p><p><img src="https://image.nicebao.com/luntan/e5354c1f8d9e6880e48ae3df7710bbf0.webp" alt="image-20240111115400959"></p><p><img src="https://image.nicebao.com/luntan/bd6d659ea6b4bcf8fc1ee4a8b8be5ff0.webp" alt="image-20240111115419299"></p><p><img src="https://image.nicebao.com/luntan/068af593153edc59b9936ca6ee718ca9.webp" alt="image-20240111115459913"><img src="https://image.nicebao.com/luntan/881c122f894ab7531b51d021322b0d98.webp" alt="image-20240111115823215"></p><p><em>我这里桶类型有错误是私人的，点击桶设定，即可改为公共所有</em></p><p>至此，我们就成功的创建了一个桶，然后按照图片中①②③④填到memos中的对应位置即可</p><h2 id="memos应用程序"><a href="#memos应用程序" class="headerlink" title="memos应用程序"></a>memos应用程序</h2><p>安装好memos后我们就能打开网页进行发文了，下面是官方推荐的几个扩展程序</p><p>如果memos的安卓端下载不了，可以给我发邮件，我传给你</p><ul><li><a href="https://memos.moe/">Moe Memos</a> - 适用于 iOS 和 Android 的第三方客户端</li><li><a href="https://github.com/lmm214/memos-bber">lmm214&#x2F;memos-bber</a> - Chrome 扩展程序</li><li><a href="https://github.com/Rabithua/memos_wmp">Rabithua&#x2F;memos_wmp</a> - 微信小程序</li><li><a href="https://github.com/qazxcdswe123/telegramMemoBot">qazxcdswe123&#x2F;telegramMemoBot</a> - 电报机器人</li><li><a href="https://github.com/eallion/memos.top">eallion&#x2F;memos.top</a> - 使用 Memos API 呈现的静态页面</li><li><a href="https://github.com/EINDEX/logseq-memos-sync">eindex&#x2F;logseq-memos-sync</a> - Logseq 插件</li><li><a href="https://github.com/quanru/obsidian-periodic-para#daily-record">quanru&#x2F;obsidian-periodic-para</a> - 黑曜石插件</li><li><a href="https://github.com/JakeLaoyu/memos-import-from-flomo">JakeLaoyu&#x2F;memos-import-from-flomo</a> - 导入数据。支持flomo，微信阅读</li><li><a href="https://www.icloud.com/shortcuts/1eaef307112843ed9f91d256f5ee7ad9">快速备忘录</a> - 快捷指令（iOS、iPadOS 或 macOS）</li><li>Memos Raycast 扩展 - <a href="https://www.raycast.com/JakeYu/memos">Raycast 扩展</a></li><li><a href="https://github.com/xudaolong/memos-desktop">Memos Desktop</a> - 适用于 MacOS 和 Windows 的第三方客户端</li><li>MemosGallery - 使用 <a href="https://github.com/BarryYangi/MemosGallery">Memos</a> API 呈现的静态库</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘录memos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java字符串匹配：Pattern与Matcher类介绍</title>
      <link href="/post/78aa25f0.html"/>
      <url>/post/78aa25f0.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>Java中的<code>Pattern</code>类是一个正则表达式的编译表示。它定义了一个模式（pattern），这个模式可以用于创建<code>Matcher</code>对象，用来匹配输入的字符串。<code>Matcher</code>类则用于对字符串进行匹配操作。</p><h3 id="1-1-Pattern类"><a href="#1-1-Pattern类" class="headerlink" title="1.1 Pattern类"></a>1.1 <code>Pattern</code>类</h3><p><code>Pattern</code>类的主要作用是将正则表达式编译成一个可供<code>Matcher</code>类使用的模式。它提供了多种方法，用于将正则表达式字符串编译为<code>Pattern</code>对象。此外，它还提供了一些静态方法，比如<code>matches()</code>用于匹配字符串是否符合给定的模式。</p><h3 id="1-2-Matcher类"><a href="#1-2-Matcher类" class="headerlink" title="1.2 Matcher类"></a>1.2 <code>Matcher</code>类</h3><p><code>Matcher</code>类是<code>Pattern</code>类的实例化对象，用于对输入字符串进行匹配操作。它提供了诸如<code>find()</code>、<code>group()</code>、<code>start()</code>、<code>end()</code>等方法，用于在输入字符串中查找匹配模式的子串，并提供有关匹配信息的详细数据。</p><h2 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h2><h3 id="2-1-Pattern的使用"><a href="#2-1-Pattern的使用" class="headerlink" title="2.1 Pattern的使用"></a>2.1 <code>Pattern</code>的使用</h3><p>要使用<code>Pattern</code>类，首先需要使用其静态方法<code>compile()</code>将正则表达式编译为一个<code>Pattern</code>对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;a*b&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样就创建了一个匹配零个或多个字符’a’后跟字符’b’的模式。接下来，可以使用这个<code>Pattern</code>对象创建一个<code>Matcher</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;aaaaab&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-Matcher的使用"><a href="#2-2-Matcher的使用" class="headerlink" title="2.2 Matcher的使用"></a>2.2 <code>Matcher</code>的使用</h3><p>有了<code>Matcher</code>对象，就可以对输入的字符串进行匹配操作。可以使用<code>find()</code>方法查找匹配的子串，并使用<code>group()</code>方法获取匹配的子串。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Found match at: &quot;</span> + matcher.start() + <span class="string">&quot; - &quot;</span> + matcher.end());</span><br><span class="line">    System.out.println(<span class="string">&quot;Matched substring: &quot;</span> + matcher.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将输出匹配到的子串在输入字符串中的起始和结束位置，并打印匹配到的子串内容。</p><h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h2><p>让我们通过一些示例来演示<code>Pattern</code>和<code>Matcher</code>的使用。</p><h3 id="3-1-匹配邮箱地址"><a href="#3-1-匹配邮箱地址" class="headerlink" title="3.1 匹配邮箱地址"></a>3.1 匹配邮箱地址</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;Emails: example1@email.com, example2@email.com&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">emailPattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]&#123;2,&#125;\\b&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">emailMatcher</span> <span class="operator">=</span> emailPattern.matcher(input);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (emailMatcher.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Found email: &quot;</span> + emailMatcher.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>\\b</code>: 表示单词边界，匹配单词的开始或结束。</li><li><code>[A-Za-z0-9._%+-]+</code>: 匹配电子邮件地址的用户名部分，可以包含字母、数字、以及一些特殊字符（<code>.</code>、<code>_</code>、<code>%</code>、<code>+</code>、<code>-</code>），<code>+</code>表示匹配前面的字符集至少一次或多次。</li><li><code>@</code>: 匹配电子邮件地址中的 <code>@</code> 符号。</li><li><code>[A-Za-z0-9.-]+</code>: 匹配电子邮件地址的域名部分，可以包含字母、数字、<code>.</code>、<code>-</code>，同样使用 <code>+</code> 表示匹配至少一次或多次。</li><li><code>\\.</code>: 匹配电子邮件地址中的 <code>.</code> 符号，需要使用 <code>\\</code> 进行转义，表示匹配实际的点号字符。</li><li><code>[A-Z|a-z]&#123;2,&#125;</code>: 匹配顶级域名，即邮件地址的后缀部分，比如 <code>.com</code>、<code>.org</code> 等。<code>&#123;2,&#125;</code>表示至少匹配两个或更多字母，<code>[A-Z|a-z]</code>表示大写或小写字母的集合。</li><li><code>\\b</code>: 再次使用单词边界，表示匹配单词的结束。</li></ul></blockquote><h3 id="3-2-替换字符串中的特定内容"><a href="#3-2-替换字符串中的特定内容" class="headerlink" title="3.2 替换字符串中的特定内容"></a>3.2 替换字符串中的特定内容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;The cat and the hat&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\b cat \\b&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(input);</span><br><span class="line"><span class="type">String</span> <span class="variable">replacedString</span> <span class="operator">=</span> matcher.replaceAll(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Replaced string: &quot;</span> + replacedString);</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>\\b</code>: 表示单词边界，确保匹配的是单独的单词而不是单词的一部分。</li><li><code>cat</code>: 匹配要查找的确切字符序列，这里是”cat”。</li></ul></blockquote><h3 id="3-3-加减乘除计算"><a href="#3-3-加减乘除计算" class="headerlink" title="3.3 加减乘除计算"></a>3.3 加减乘除计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正则表达式匹配数字和运算符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;([\\d.]+)\\s*([-+*/])\\s*([\\d.]+)&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(expression);</span><br><span class="line"><span class="keyword">if</span>(matcher.find())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> <span class="variable">operand1</span> <span class="operator">=</span> Double.parseDouble(matcher.group(<span class="number">1</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">operator</span> <span class="operator">=</span> matcher.group(<span class="number">2</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">operand2</span> <span class="operator">=</span> Double.parseDouble(matcher.group(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// 根据运算符计算结果</span></span><br><span class="line"><span class="keyword">switch</span>(operator)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> operand1 + operand2;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> operand1 - operand2;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> operand1 * operand2;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> operand1 / operand2;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 处理其他运算符</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>([\\d.]+)</code>: 这个部分匹配一个数字，包括小数点，<code>[\\d.]</code>表示可以匹配数字0到9和小数点”.”，<code>+</code>表示匹配一个或多个前面的字符。整个括号表示捕获这个数字。</li><li><code>\\s*</code>: 这部分匹配零个或多个空白字符，包括空格、制表符等。</li><li><code>([-+*/])</code>: 这个部分匹配一个运算符号，可以是加号、减号、乘号或除号。括号里的内容表示捕获这个运算符号。</li><li><code>\\s*</code>: 再次匹配零个或多个空白字符。</li><li><code>([\\d.]+)</code>: 类似第一个部分，再次匹配一个数字，也会被捕获。</li></ul></blockquote><h2 id="4-深入了解"><a href="#4-深入了解" class="headerlink" title="4. 深入了解"></a>4. 深入了解</h2><h3 id="4-1-捕获组"><a href="#4-1-捕获组" class="headerlink" title="4.1 捕获组"></a>4.1 捕获组</h3><p>捕获组是<code>Pattern</code>和<code>Matcher</code>中的一个重要概念。通过在正则表达式中使用括号来创建捕获组，可以方便地提取匹配的特定部分。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3&#125;)-(\\d&#123;3&#125;)-(\\d&#123;4&#125;)&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;Phone numbers: 123-456-7890, 987-654-3210&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Full match: &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;Area code: &quot;</span> + matcher.group(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;Prefix: &quot;</span> + matcher.group(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;Suffix: &quot;</span> + matcher.group(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-贪婪与勉强匹配"><a href="#4-2-贪婪与勉强匹配" class="headerlink" title="4.2 贪婪与勉强匹配"></a>4.2 贪婪与勉强匹配</h3><p>量词（比如<code>*</code>、<code>+</code>、<code>?</code>）默认是贪婪模式，会尽可能多地匹配字符。但你也可以通过在量词后面加上<code>?</code>来实现勉强模式，即匹配尽可能少的字符。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;aaaaaa&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">greedyPattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;a+&quot;</span>);</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">reluctantPattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;a+?&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">greedyMatcher</span> <span class="operator">=</span> greedyPattern.matcher(text);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">reluctantMatcher</span> <span class="operator">=</span> reluctantPattern.matcher(text);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (greedyMatcher.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Greedy match: &quot;</span> + greedyMatcher.group());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (reluctantMatcher.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Reluctant match: &quot;</span> + reluctantMatcher.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-示例扩展"><a href="#5-示例扩展" class="headerlink" title="5. 示例扩展"></a>5. 示例扩展</h2><h3 id="5-1-使用命名捕获组"><a href="#5-1-使用命名捕获组" class="headerlink" title="5.1 使用命名捕获组"></a>5.1 使用命名捕获组</h3><p>Java支持使用<code>(?&lt;name&gt;regex)</code>的语法来创建命名捕获组，方便管理和提取数据。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;Date: 2023-11-22&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Year: &quot;</span> + matcher.group(<span class="string">&quot;year&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;Month: &quot;</span> + matcher.group(<span class="string">&quot;month&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;Day: &quot;</span> + matcher.group(<span class="string">&quot;day&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>(?&lt;year&gt;\\d&#123;4&#125;)</code>: 这部分使用了命名捕获组，<code>(?&lt;year&gt;</code> 表示开始一个名为 “year” 的捕获组。<code>\\d&#123;4&#125;</code> 匹配四个数字字符，因此它匹配年份的部分。</li><li><code>-(?&lt;month&gt;\\d&#123;2&#125;)</code>: 同样是一个命名捕获组，<code>(?&lt;month&gt;</code> 表示开始一个名为 “month” 的捕获组。<code>\\d&#123;2&#125;</code> 匹配两个数字字符，匹配月份的部分。</li><li><code>-(?&lt;day&gt;\\d&#123;2&#125;)</code>: 也是一个命名捕获组，<code>(?&lt;day&gt;</code> 表示开始一个名为 “day” 的捕获组。<code>\\d&#123;2&#125;</code> 匹配两个数字字符，匹配日期的部分。</li></ul></blockquote><h3 id="5-2-验证密码强度"><a href="#5-2-验证密码强度" class="headerlink" title="5.2 验证密码强度"></a>5.2 验证密码强度</h3><p>使用正则表达式来验证密码强度是一个常见的应用。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;Passw0rd!&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&amp;+=!])(?=\\S+$).&#123;8,&#125;$&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(password);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Strong password!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Weak password!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>^</code>: 表示匹配字符串的开始位置。</li><li><code>(?=.*[0-9])</code>: 这个部分是一个正向前视断言，用于确认字符串中至少包含一个数字。</li><li><code>(?=.*[a-z])</code>: 类似于上面，确认字符串中至少包含一个小写字母。</li><li><code>(?=.*[A-Z])</code>: 同样是一个断言，确认字符串中至少包含一个大写字母。</li><li><code>(?=.*[@#$%^&amp;+=!])</code>: 这个断言用于确认字符串中至少包含特殊字符，如 @、#、$、%、^、&amp;、+、&#x3D; 或 !。</li><li><code>(?=\\S+$)</code>: 这是一个断言，用于确认整个字符串中不包含空格。</li><li><code>.&#123;8,&#125;</code>: 匹配至少包含8个或更多字符。</li><li><code>$</code>: 表示匹配字符串的结束位置。</li></ul></blockquote><p><strong>注意！在正则表达式中，<code>^</code> 在不同的位置有不同的含义</strong></p><ul><li>当它在字符集合 <code>[ ]</code> 内部使用时，它表示字符集的取反，即匹配不在该字符集内的字符。例如 <code>[^0-9]</code> 表示匹配除了数字之外的任何字符。</li><li>当 <code>^</code> 在正则表达式的开头使用时，它表示匹配字符串的开头位置。它不是反义的意思，而是指定匹配的起始位置。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如上介绍了Pattern和Matcher的几个基本用法，并介绍了一些正则表达式的写法</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理</title>
      <link href="/post/7446d9da.html"/>
      <url>/post/7446d9da.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络原理"><a href="#网络原理" class="headerlink" title="网络原理"></a>网络原理</h1><h2 id="一-传输层（UDP报文）"><a href="#一-传输层（UDP报文）" class="headerlink" title="一.传输层（UDP报文）"></a>一.传输层（UDP报文）</h2><h3 id="1-1-UDP报文结构"><a href="#1-1-UDP报文结构" class="headerlink" title="1.1 UDP报文结构"></a>1.1 UDP报文结构</h3><p> <strong>UDP是传输层协议之一,其主要特点是无连接,不可靠传输,面向数据报,全双工</strong></p><p><img src="https://image.nicebao.com/luntan/202311121308376.webp" alt="image-20231026205157171"> </p><blockquote><p>UDP报文主体分为两个部分:UDP报头(占8个字节)+UDP数据&#x2F;UDP载荷</p><p>UPD报头:源端口号+目的端口号+数据报长度+校验和</p></blockquote><ul><li><p>源端口号和目的端口号</p><ul><li>源端口号和目的端口号均占用16个比特位，即为2个字节</li></ul></li><li><p>UDP长度</p><ul><li>总共16位,占两个字节</li><li>UDP报文长度&#x3D;UDP报头(首部)+UDP载荷</li><li>2个字节能表示的数据范围是0~65535,也就是能够表示的报文长度是65536字节(Byte),转换成KB,65536&#x2F;1024 &#x3D; 64 KB 这就是一个UDP报文所能表示的最大长度.</li></ul></li><li><p>校验和</p><ul><li>数据在传输的时候,本质上是0&#x2F;1bit流,通过光信号或者电信号来表示,如果在传输的时候收到干扰,就可能会出现比特翻转现象.这个时候就需要校验和校验数据是否出错.</li></ul></li></ul><h3 id="1-2UDP报文特点"><a href="#1-2UDP报文特点" class="headerlink" title="1.2UDP报文特点"></a>1.2UDP报文特点</h3><p><strong>1.无连接</strong></p><p>  知道对端的  IP  和端口号就直接进行传输，不需要建立连接；  </p><p><strong>2.不可靠</strong></p><p> 没有任何安全机制，发送端发送数据报以后，如果因为某些问题无法发送到对端， UDP  协议层也不会给应用层返回任何错误信息；  </p><p><strong>3.面向数据报</strong></p><p> 应用层无论交给  UDP  多大的报文，UDP原样发送，不会拆分或者合并；</p><p><strong>4.缓冲区</strong></p><p>  UDP  只有接收缓冲区，没有发送缓冲区</p><p><strong>5.大小受限</strong></p><p>  UDP  协议首部中有一个  16  位的最大长度。也就是说一个  UDP  能传输的数据最大长度是  64K  （包含 UDP首部）。  </p><h3 id="1-3-基于UDP的应用层协议"><a href="#1-3-基于UDP的应用层协议" class="headerlink" title="1.3 基于UDP的应用层协议"></a>1.3 基于UDP的应用层协议</h3><blockquote><ul><li>NFS：网络文件系统 </li><li>TFTP：简单文件传输协议 </li><li>DHCP：动态主机配置协议 </li><li>BOOTP：启动协议（用于无盘设备启动） </li><li>DNS：域名解析协议</li></ul></blockquote><h2 id="二-传输层（TCP报文）"><a href="#二-传输层（TCP报文）" class="headerlink" title="二.传输层（TCP报文）"></a>二.传输层（TCP报文）</h2><h3 id="2-1-TCP报文结构"><a href="#2-1-TCP报文结构" class="headerlink" title="2.1 TCP报文结构"></a>2.1 TCP报文结构</h3><p><img src="https://image.nicebao.com/luntan/202311121308377.webp" alt="image-20231029232919706"></p><p><strong>源&#x2F;目的端口号</strong>：表示数据是从哪个进程进入，从哪个进程出去</p><p><strong>32位序号&#x2F;32位确认号：</strong>后面详细讲；</p><p><strong>4位TCP报头长度：</strong>表示该TCP头部有多少个32位bit（有多少个4字节）；所以TCP头部最大长度是</p><p>15 * 4 &#x3D; 60</p><p><strong>6位标志位:</strong></p><ul><li><p>URG：紧急指针是否有效</p></li><li><p>ACK：确认号是否有效</p></li><li><p>PSH：提示接收端应用程序立刻从TCP缓冲区把数据读走</p></li><li><p>RST：对方要求重新建立连接；我们把携带RST标识的称为<strong>复位报文段</strong></p></li><li><p>SYN：请求建立连接；我们把携带SYN标识的称为<strong>同步报文段</strong></p></li><li><p>FIN：通知对方，本端要关闭了，我们称携带FIN标识的为<strong>结束报文段</strong></p></li></ul><p><strong>16位窗口大小</strong>：后面再说</p><p><strong>16位校验和</strong>：发送端填充，CRC校验。接收端校验不通过，则认为数据有问题。此处的检验和不光</p><p>包含TCP首部，也包含TCP数据部分。</p><p><strong>16位紧急指针：</strong>标识哪部分数据是紧急数据；</p><p><strong>40字节头部选项：</strong>暂时忽略；</p><h3 id="2-2-TCP特点"><a href="#2-2-TCP特点" class="headerlink" title="2.2 TCP特点"></a>2.2 TCP特点</h3><ul><li>有连接</li><li>可靠传输</li><li>面向字节流</li><li>全双工<br><strong>其中，可靠传输是TCP最为重要的一点，TCP是通过六个重要的机制来实现的这一点</strong></li></ul><h4 id="2-2-1-确认应答"><a href="#2-2-1-确认应答" class="headerlink" title="2.2.1 确认应答"></a>2.2.1 确认应答</h4><p><strong>确认应答是TCP最为核心的机制，支持了TCP的可靠传输</strong></p><p>发送方将数据发送给接收方之后，接收方收到数据就会返回一个竞答报文（ack，acknowledge）</p><p>发送发，如果收到了这个应答报文，就知道自己的数据是否发送成功了。</p><p><img src="https://image.nicebao.com/luntan/202311121308378.webp" alt="image-20231103222535849"></p><p>但当连续发送多条数据时，可能会出现”先发后至”即某个数据时先发的，反而晚到了，例如图中的情况。</p><p><img src="https://image.nicebao.com/luntan/202311121308379.webp" alt="image-20231103223835167"></p><p>那么为什么会出现先发后至呢？<br>因为网络上从A-&gt;B的路线有很多，两个包从A-&gt;B走的路线并不一定是相同的。另外每个节点（交换机&#x2F;路由器)的繁忙程度也是不同的。此时数据包传输就像过红绿灯一样，有的先到，有的后到了。</p><blockquote><p>TCP在此处就要完成两个工作：</p><p>1.确保应答报文和发送输出的数据能对上号，不要出现歧义</p><p>2.确保在出现后发后至的现象时，能够让应用程序仍然按照正确顺序来理解数据</p></blockquote><p><img src="https://image.nicebao.com/luntan/202311121308380.webp" alt="image-20231104101830784"></p><p>TCP将每个字节的数据都进行了编号，即为序列号。</p><p><img src="https://image.nicebao.com/luntan/202311121308381.webp" alt="image-20231104101904922"></p><p>每一个ACK都带有对应的确认序列号，意思是告诉发送者，我已经收到了哪些数据；下一次你从哪里开始发。确认序列号的数值就是收到的最后一个字节编号再+1</p><p>这里所说到的序列号，就是图中的32位序号和32位确认序号。序号占用 4 字节，即 32 位。也就是说表示的数据范围是42亿9千万，即为4GB。</p><p><strong>其次，TCP报头中记录的序号，是这一次传输的在和数据中第一个字节的序号，剩下其他字节的序号，都需要依次的推出。</strong></p><p><strong>那么我们是如何区分这是普通报文还是确认应答报文呢？</strong></p><blockquote><p>ACK为0即表示这是一个普通报文，此时只有32位序号是有效的</p><p>ACK为1即表示这是一个应答报文，这个报文的32位序号和确认序号都是有效的</p></blockquote><h4 id="2-2-2超时重传"><a href="#2-2-2超时重传" class="headerlink" title="2.2.2超时重传"></a>2.2.2超时重传</h4><p>确认应答机制，描述的是一个比较理想的情况，如果网络传输过程中出现了丢包，怎么办？</p><p>路由器&#x2F;交换机就像一个交通枢纽一样，结构复杂，传输的数据量也不确定，如果设备此时过于繁忙，后面新来的数据等太久了就会被抛弃，网络负载越高，就越繁忙从而容易丢包。<br>例如当我们ping一个网站时候，如果提示请求超时，那么就意味着发生了丢包现象，此时网站多半是负载过高（禁ping情况除外）。<br>那么这时超时重传机制就发挥了重大作用，超时重传相当于针对确认应答机制做出的重要补充！</p><p><img src="https://image.nicebao.com/luntan/202311121308382.webp" alt="image-20231104111203066"></p><p><img src="https://image.nicebao.com/luntan/202311121308383.webp" alt="image-20231104111151862"></p><p>站在发送方的角度，是<strong>无法区分</strong>这两种情况的，无论发生哪一种，都需要重传。第一次丢了，重传一下试试，很大概率就能传过去。</p><p>因此接收方会收到很多重复数据。那么TCP协议需要能够识别出那些包是重复的包，并且把重复的丢弃掉。</p><blockquote><p>那么tcp是如何去重的呢？<br>TCP会在内核中，给每个socket对象都申请一个内从空间，相当于一个队列，类似生产者消费者模型，也被称作“接受缓冲区”。接收到的数据都会被存放在这里，并按照<strong>序号进行排序</strong>。此时就可以轻松地找到新接收到的数据是否重复了。</p></blockquote><p><strong>那么，超时重传的时间如何确定？</strong></p><ul><li><p>最理想的情况下，找到一个最小的时间，保证 “确认应答一定能在这个时间内返回”。</p></li><li><p>但是这个时间的长短，随着网络环境的不同，是有差异的。</p></li><li><p>如果超时时间设的太长，会影响整体的重传效率；</p></li><li><p>如果超时时间设的太短，有可能会频繁发送重复的包；</p></li></ul><p>TCP为了保证无论在任何环境下都能比较高性能的通信，因此会动态计算这个最大超时时间。</p><ul><li><p>Linux中（BSD Unix和Windows也是如此），超时以500ms为一个单位进行控制，每次判定</p></li><li><p>超时重发的超时时间都是500ms的整数倍。</p></li><li><p>如果重发一次之后，仍然得不到应答，等待 2*500ms 后再进行重传。</p></li><li><p>如果仍然得不到应答，等待 4*500ms 进行重传。依次类推，以指数形式递增。</p></li><li><p>累计到一定的重传次数，TCP认为网络或者对端主机出现异常，强制关闭连接。</p></li></ul><h4 id="2-2-3-连接管理"><a href="#2-2-3-连接管理" class="headerlink" title="2.2.3 连接管理"></a>2.2.3 连接管理</h4><h5 id="2-2-3-1-三次挥手"><a href="#2-2-3-1-三次挥手" class="headerlink" title="2.2.3.1 三次挥手"></a>2.2.3.1 三次挥手</h5><p>在正常情况下，TCP要经过三次握手建立连接，四次挥手断开连接</p><p>tcp这里的握手，类似于给对方传输一个简短的，没有业务的数据报，通过这个数据报，来唤起对方的注意，从而触发后续操作。</p><p>握手这个操作并非是TCP独有的，甚至不是网络通信独有的，在计算机中很多操作都会涉及到握手。</p><blockquote><p>例如手机充电头的快充协议</p><p>U盘的3.0 2.0端口</p><p>……</p></blockquote><p>TCP的三次握手.TCP在建立连接的过程中，需要通信双方一共打三次招呼才能建立连接。</p><p><img src="https://image.nicebao.com/luntan/202311121308384.webp" alt="image-20231104124702750"></p><p>A想和B建立连接，A就会主动发起握手操作。实际开发中，主动发起的一方就是所谓的“客户端”，被动接受的乙方就是“服务器”。此时我手完成，A和B记录了对方的信息。</p><p>建立连接的过程，其实是通信双发都要给对方发送SYN，也要给对方返回ack。一共是4次握手，但是中间的两次恰好可以合并成一次。</p><p><img src="https://image.nicebao.com/luntan/202311121308385.webp" alt="image-20231104133811855"></p><p><strong>三次握手的作用</strong></p><ul><li><p>投石问路，确认当期网络是否畅通</p></li><li><p>让发送方和接收方都能确认自己的发送能力和接受能力均正常</p></li><li><p>让通信双方，在握手过程中，针对一些重要的参数，进行<strong>协商</strong></p></li></ul><p>协商：握手这里的协商信息是有很多的，例如tcp通信过程中的序号从几开始，就是双方协商出来的，每次建立连接的时候，都会写上出一个比较大的，和上次不一样的数值</p><p><img src="https://image.nicebao.com/luntan/202311121308386.webp" alt="image-20231104134538454"></p><p>这种协商设定，是避免了“前朝的剑，斩本朝的官”</p><p>当网络不好时，客户端和服务端之间可能会断开连接，再重新建立连接.重连的时候，就可能在新的连接好了之后，旧连接的数据姗姗来迟。这种迟到的数据就应该毒气，不能让上个朝代的数据影响本朝的业务逻辑。</p><p>那么如何区分数据是否来自上个朝代呢？</p><p>则可以通过上述序号来区分，如果收到的数据序号和当前正常数据序号差异非常大，则可以判定是上个朝代的数据就可以直接丢弃了。</p><p><img src="https://image.nicebao.com/luntan/202311121308387.webp" alt="image-20231104140045469"></p><h5 id="2-3-3-2四次挥手"><a href="#2-3-3-2四次挥手" class="headerlink" title="2.3.3.2四次挥手"></a>2.3.3.2四次挥手</h5><p>建立连接一般是由客户端主动发起</p><p>断开连接，客户端和服务端都可以主动发起</p><p><img src="https://image.nicebao.com/luntan/202311121308388.webp" alt="image-20231104141632143"></p><p>四次挥手和三次握手不同.此处的四次挥手能否把中间的两次交互合二为一呢？不一定！</p><p>不能合并的原因是ACK和第二个FIN的触发时机是不同的。ACK是内核的响应，B收到FIN就会立刻返回ACK。但是第二个FIN是应用程序的代码处罚的。B这边调用了close()方法才会触发FIN。</p><p>FIN就会在socket对象click时被发起，可能是手动调用close方法，也可能是进程结束。</p><blockquote><p>像前面的三次回收，ACK和第二个SYN都是同一时间内核触发的，可以合并</p><p>这里的四次挥手，ACK是内核触发的，第二个FIN是应用程序执行close触发的，时机不同不能合并。</p><p>但是TCP还有一个机制，延时应答，能够拖延ACK的回应时间，一旦ACK滞后，就有机会和下一个FIN合并在一起了。</p></blockquote><p><img src="https://image.nicebao.com/luntan/202311121308389.webp" alt="image-20231104152817592"></p><p>哪一方主动断开连接，那一方就会进入TIME_WAIT状态。TIME_WAIT状态存在的意义在于，防止最后一个ACK丢失，留的一个后手。</p><p><strong>如果最后一个ACK丢失。</strong></p><p>站在B的角度，B就会超时重传，重新发送一遍FIN</p><p>如果刚才A没有TIME_WAIT状态，就意味着A这时就已经真正的释放连接了。此时重传的FIN也就没人处理，没人能够返回ACK了，不永远也收不到ACK了</p><p>A这边使用了TIME_WAIT状态机就会进行等待，等待的这个时间就是为了处理后续B重传的FIN。此时有重传的FIN来了，就可以继续返回ACK。</p><p>那么TIME_WAIT状态持续多久呢？</p><p>建设网络上两个节点通信消耗的最大时间为MSL，此时TIME_WAIT的等待时间就是2MSL。</p><h4 id="2-3-4滑动窗口"><a href="#2-3-4滑动窗口" class="headerlink" title="2.3.4滑动窗口"></a>2.3.4滑动窗口</h4><p>前面所讲的三个机制，都是在保证tcp的可靠性。而滑动窗口的目的是为了提高效率，缩短确认应答的等待时间。</p><p><img src="https://image.nicebao.com/luntan/202311121308390.webp" alt="image-20231104154018754"></p><p>既然这样一发一收的方式性能较低，那么我们一次发送多条数据，就可以大大的提高性能（其实是将多个段的等待时间重叠在一起了）。</p><p><img src="https://image.nicebao.com/luntan/202311121308391.webp" alt="image-20231104154100315"></p><p>批量传输数据，就是不等ack返回，直接发送下一个数据。但批量传输也不是“无限的”传输。批量传输也是存在一定的上限，达到上限之后，再统一ACK</p><p><img src="https://image.nicebao.com/luntan/202311121308392.webp" alt="image-20231104154424524"></p><ul><li><p>窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。上图的窗口大小就是4000个字节（四个段）。</p></li><li><p>发送前四个段的时候，不需要等待任何ACK，直接发送；</p></li><li><p>收到第一个ACK后，滑动窗口向后移动，继续发送第五个段的数据；依次类推；</p></li><li><p>操作系统内核为了维护这个滑动窗口，需要开辟 <strong>发送缓冲区</strong> 来记录当前还有哪些数据没有应答；只有确认应答过的数据，才能从缓冲区删掉；窗口越大，则网络的吞吐率就越高；</p></li></ul><p>TCP的初心是“可靠传输”上述滑动窗口中，确认应答是可以正常工作的，但是如果出现了丢包咋办？这里的重传，相比于前面的超时重传又有了变化。</p><p><strong>情况一.ACK丢失</strong></p><p><img src="https://image.nicebao.com/luntan/202311121308393.webp" alt="image-20231104160820420"></p><p>这种情况下，部分ACK丢了并不要紧，因为可以通过后续的ACK进行确认；</p><p>确认序号，表示的含义是，当前序号之前的数据已经确认到了，下一个应该从确认序号这里，继续发送。如果1001这个ack丢失，但是2001ack到了，那么就代表2001之前的数据已经确认传输成功了，涵盖了1001的情况。</p><p><img src="https://image.nicebao.com/luntan/202311121308394.webp" alt="image-20231104160832753"></p><p>由于1001~2000这个数据丢失了，此处返回的ack仍然是索要1001，无论当前传输的数值是多少，都会一直索要1001这个数据，但这个过程中B仍然会接受数据，并把接受的数据默默地存起来。</p><p>此时主机A看到B连续的几个ACK都是在索要1001，A就会重传一次1001。1001~2000顺利到达，B所要的就变成了7001</p><blockquote><p>如果通信双方传输的数据量比较小，也并不频发，就仍是使用普通的确认应答和普通的超时重传</p><p>如果通信双方，传输数据量更大，也比较频繁，就会进入到滑动窗口模式，按照快速重传的方式处理</p></blockquote><h4 id="2-2-5-流量控制"><a href="#2-2-5-流量控制" class="headerlink" title="2.2.5 流量控制"></a>2.2.5 流量控制</h4><p>站在接收方的角度，反向制约发送方的传输速率</p><p>发送方发送的速率，不应该超过接收方处理的能力</p><p><img src="https://image.nicebao.com/luntan/202311121308395.webp" alt="image-20231104211508828"></p><p>数据到达B的系统内核中时，tcp socket对象上带有接受缓冲区。A -&gt; B发送的数据，就会先到达B的接受缓冲区。</p><p>B再通过应用程序调用read这样的方法，把接受缓冲区中的数据读出来，进一步进行处理。类似一个生产者消费者模型。0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </p><ul><li><p>接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 “窗口大小” 字段，通过ACK端通知发送端；</p></li><li><p>窗口大小字段越大，说明网络的吞吐量越高；</p></li><li><p>接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端；</p></li><li><p>发送端接受到这个窗口之后，就会减慢自己的发送速度；</p></li><li><p>如果接收端缓冲区满了，就会将窗口置为0；这时发送方不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端。</p></li></ul><p><img src="https://image.nicebao.com/luntan/202311121308396.webp" alt="image-20231104210401109"></p><p>接收端如何把窗口大小告诉发送端呢？回忆我们的TCP首部中，有一个16位窗口字段，就是存放了窗口大小信息；</p><p>那么问题来了，16位数字最大表示65535，那么TCP窗口最大就是65535字节么？</p><p>实际上，TCP首部40字节选项中还包含了一个窗口扩大因子M，实际窗口大小是 窗口字段的值左移 M 位；                                         </p><h4 id="2-2-6拥塞控制"><a href="#2-2-6拥塞控制" class="headerlink" title="2.2.6拥塞控制"></a>2.2.6拥塞控制</h4><p>虽然TCP有了滑动窗口这个大杀器，能够高效可靠的发送大量的数据。但是如果在刚开始阶段就发送大量的数据，仍然可能引发问题。</p><p>因为网络上有很多的计算机，可能当前的网络状态就已经比较拥堵。在不清楚当前网络状态下，贸然发送大量的数据，是很有可能引起雪上加霜的。</p><p><img src="https://image.nicebao.com/luntan/202311121308397.webp" alt="image-20231104221749066"></p><p>TCP引入 <strong>慢启动</strong> 机制，先发少量的数据，探探路，摸清当前的网络拥堵状态，再决定按照多大的速度传输数据，随着窗口大小不断增大，达到一定程度，可能中间的节点就会出现问题了，此时这个节点发送方发现丢包了，就把窗口大小调整小。此时如果发现还是继续丢包，就继续缩小，如果不丢包了就继续尝试增大。</p><p>在这个过程中，发送方不停地调整窗口大小，逐渐达成动态平衡。这种做法就相当于把所有中间节点看做成一个整体，通过实验的方式，来找到中间节点的瓶颈在哪里。</p><blockquote><p>流量控制 拥塞控制</p><p>都是在限制发送方发送的窗口大小，最终发送的窗口大小，取决于流量控制和拥塞控制中窗口的较小值。</p></blockquote><h4 id="2-2-67延时应答"><a href="#2-2-67延时应答" class="headerlink" title="2.2.67延时应答"></a>2.2.67延时应答</h4><p>正常情况：A把数据传输给B，B就会立刻返回ack给A</p><p>延时应答：A传输给B，此时B等一会再返回ACK给A                                                                                </p><p>延时应答本质上也是为了提升传输速率。<strong>发送方的窗口大小，就是传输效率的关键</strong>。</p><p>假设接收端缓冲区为1M。一次收到了500K的数据；如果立刻应答，返回的窗口就是500K。但实际上可能处理端处理的速度很快，10ms之内就把500K数据从缓冲区消费掉了。在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些，也能处理过来。如果接收端稍微等一会再应答，比如等待200ms再应答，那么这个时候返回的窗口大小就是1M。</p><p>一定要记得，窗口越大，网络吞吐量就越大，传输效率就越高。我们的目标是在保证网络不拥塞的情况尽量提高传输效率；</p><p>也是延时应答，促成了四次挥手，能够三次挥完。</p><h4 id="2-2-8-捎带应答"><a href="#2-2-8-捎带应答" class="headerlink" title="2.2.8 捎带应答"></a>2.2.8 捎带应答</h4><p>在延时应答的基础上，进一步提高效率。（类似于四次挥手中FIN和ACK一同发回的情况）网络通信过程中，往往是这种“一问一答”这样通信模型。 </p><p><img src="https://image.nicebao.com/luntan/202311121308398.webp" alt="image-20231104232416343"></p><p>ack是内核立即返回的，response则是应用程序代码来返回的。由于TCP引入了延时应答，ACK不一定是立即返回，可能要等一会。在这过程中，B正好把response计算好了，计算好之后就会把response返回，于是顺便把刚才要返回的ack带上了。此时ACK和response就合并成一个数据了。</p><h4 id="2-2-9面向字节流"><a href="#2-2-9面向字节流" class="headerlink" title="2.2.9面向字节流"></a>2.2.9面向字节流</h4><p>这里有一个重要的问题，粘包问题（并非TCP独有的，所有面向字节流的机制都有类似情况）</p><p>此处包是指应用层数据报，如果同时有多个应用层数据包被传说过去，此时就容易出现粘包问题。</p><p><img src="https://image.nicebao.com/luntan/202311121308399.webp" alt="image-20231104233829207"></p><p>站在传输层的角度，TCP是一个一个传输过来，并按序号排列好的。但站在应用层的角度，看到的只是一串连续的数字。</p><p>相比之下，像UDP这样的面向数据包的通信方式，就不会出现上述情况。</p><p>UDP接受缓冲区里的数据，就相当于一个一个的DatagramPacket对象。应用程序读取的时候，能清晰的知道哪里到哪里是一个完整的数据。使用UDP的时候，要么收到完整的UDP报文，要么什么也不收。 不会出现收到半份数据包的情况。</p><p><img src="https://image.nicebao.com/luntan/202311121308400.webp" alt="image-20231104234311247"></p><p><strong>那么如何避免出现粘包问题呢？</strong></p><ul><li><p>对于定长的包，可以固定读写大小</p></li><li><p>对于变长的包，可以在报头写入数据长度</p></li><li><p>对于变长的包，也可以在包与包之间使用不和正文数据冲突的分隔符来隔开。</p></li></ul><h4 id="2-2-10-异常情况的处理"><a href="#2-2-10-异常情况的处理" class="headerlink" title="2.2.10 异常情况的处理"></a>2.2.10 异常情况的处理</h4><p>如果在使用tcp的过程中，出现了意外如何处理呢？</p><h5 id="2-2-10-1-进程崩溃"><a href="#2-2-10-1-进程崩溃" class="headerlink" title="2.2.10.1 进程崩溃"></a>2.2.10.1 进程崩溃</h5><p>进程崩溃后，文件描述表也就释放了，等于钓鱼了socket.close()。此时可以正常触发FIN，对端收到后，返回FIN和ACK，这边再发发回ACK。和和正常关闭没有区别。</p><p><strong>TCP连接是可以独立于进程存在的。进程崩溃，TCP连接不一定消失</strong></p><h5 id="2-2-10-2-主机关机（正常情况）"><a href="#2-2-10-2-主机关机（正常情况）" class="headerlink" title="2.2.10.2 主机关机（正常情况）"></a>2.2.10.2 主机关机（正常情况）</h5><p>主机关机时，会强制终止进程（相当于进程崩溃）</p><p>此时就会和进程崩溃一样，本机发送FIN，对端返回FIN和ACK，本机再发出ACK。</p><p>但上面的情况是理想情况，即为对端发送的ACK和FIN在本机系统关闭前到了，本机才可能返回FIN。</p><p>如果ACK和FIN在系统关闭后才来，那么对端就会认为是自己的FIN丢包了，会多次重传FIN，多次重传无果后，会自动放弃连接。</p><h5 id="2-2-10-3-主机掉电（非正常情况）"><a href="#2-2-10-3-主机掉电（非正常情况）" class="headerlink" title="2.2.10.3 主机掉电（非正常情况）"></a>2.2.10.3 主机掉电（非正常情况）</h5><p>主机掉电为一瞬间的事，所以来不及发送FIN。</p><ul><li><strong>接收方掉电</strong>：对端发送数据后会一直等待接收方返回ACK。从而触发超时重传，多次重传无效后，就会 进行reset操作（发送复位报文段）进行连接重置功能。如果符文报文段发送后也没有效果，此时就会释放连接</li><li><strong>发送方掉电</strong>：对端会一直等待接收数据，此时对端是无法判断是丢包还是对方离线了。接收方会定时的给发送方发送一个不携带数据的特殊包（心跳包），询问对端是否在线，若多次五回应，就会释放连接</li></ul><h5 id="2-2-10-4-网线断开"><a href="#2-2-10-4-网线断开" class="headerlink" title="2.2.10.4 网线断开"></a>2.2.10.4 网线断开</h5><p>和主机掉电情况相似</p><p><img src="https://image.nicebao.com/luntan/202311121308401.webp" alt="image-20231105164349617"></p><hr><p>上述十种情况，是TCP中是个<strong>比较</strong>重要的机制。</p><h4 id="2-3-1-总结"><a href="#2-3-1-总结" class="headerlink" title="2.3.1 总结"></a>2.3.1 总结</h4><p><strong>可靠性：</strong> </p><ul><li>校验和序列号 </li><li>确认应答 </li><li>超时重发 </li><li>连接管理</li><li>流量控制</li><li>拥塞控制</li></ul><p><strong>提高性能：</strong> </p><ul><li>滑动窗口 </li><li>快速重传</li><li>延迟应答 </li><li>捎带应答</li></ul><h2 id="三-网络层"><a href="#三-网络层" class="headerlink" title="三.网络层"></a>三.网络层</h2><h3 id="3-1IP地址"><a href="#3-1IP地址" class="headerlink" title="3.1IP地址"></a>3.1IP地址</h3><p>IP协议：是TCP&#x2F;IP协议中最为核心的协议</p><p><img src="https://image.nicebao.com/luntan/202311172007126.webp" alt="img"></p><p>TCP&#x2F;IP协议网络上每个适配器都有唯一的IP地址</p><p>IP地址是一个32位的地址，IP地址通常被分为4段，每8个二进制为一段。为了方便阅读，通常会将每段转为十进制显示。eg 192.168.0.1&#x2F;8.8.8.8</p><p>上面我们说IP地址是一个32位地址，32位整数表示的数据范围 是42亿9千万，这就造就了IP地址是非常稀缺的。故我们通常使用如下方法来解决</p><ul><li><p>动态分配</p></li><li><p>NAT网络地址转换（主流方案）</p><p>将IP分为内网IP和公网IP</p><p>内网IP:局域网内不可重复，内网设备在访问外网时，通过路由器NAT设备进行转换</p><p>公网IP:公网IP不能重复</p></li><li><p>IPv6</p><p>IPv6使用16个字节来表示ip，IPv6的数量之大不亚于给地球上每一粒沙子都分配一个ip，但IPv6对比IPv4来说是一个全新的协议，需要更换硬件设备，故普及度较低（中国的大部分单位企业均以适配IPv6)</p></li></ul><p>IP地址分为两部分，网络ID和主机ID</p><p><strong>同一个局域网中的设备，网络号必须相同，主机号必须不同</strong></p><p>一个IP地址，那部分是网络号，哪部分是主机号并不是确定的。我们可以通过子网掩码来判断</p><p>子网掩码同IP地址一样，也都是32位的整数，左侧都是1，右侧都是0，被标记成1的部分就是网络号</p><p><img src="https://image.nicebao.com/luntan/202311121308402.webp" alt="image-20231112105035179"></p><p>例如我的子网掩码为：11111111 11111111 11111111 11111111 10000000</p><h4 id="3-1-1-分包组包"><a href="#3-1-1-分包组包" class="headerlink" title="3.1.1 分包组包"></a>3.1.1 分包组包</h4><p><strong>1.数据包是什么?</strong><br>数据包是TCP&#x2F;IP协议上通信传输中的数据单位,简称为’包’,也可以叫为’分组’.<br>数据包主要作用于网络层中,起始地与目的地都是网络层.在第三层的分组传输中.<br>像我们平时上网,其实就是数据包的交换.当我们访问网站的时候,会向服务器发送一个包进行请求,服务器在接受到请求后并作出响应,如果服务器允许我们的访问则会返回相应的数据包给我们.网页上呈现出的内容就是这样传输过来被我们看到的.<br><strong>2.数据包的结构</strong><br>一个数据包主要分成两个部分：控制信息和负载.</p><ul><li>控制信息则是表头部分,装载着’五元组’之类的信息,表明了数据的来处与去处的信息</li><li>负载则是本身要传输的数据本身.</li></ul><p><strong>3.分包是什么?为什么需要分包呢?</strong><br>每一种物理网络都会规定链路层数据帧的最大长度，称为链路层MTU(Maximum Transmission Unit).<br>IP协议在传输数据包的时候,如果一个完整的数据长度大于MTU的时候,就会把一个数据包分成若干份进行传输.这个过程就叫做分包&#x2F;分片.被分出来的每一个数据包中的包头还会含有原数据包的五元组、偏移量和其他报头信息。偏移量主要用来在传输过后数据包的组包过程中给数据排序使用.<br>分包除了可以让数据在一定规格内传输,还因为一个较大的数据包会占用较多的带宽,容易造成网络的拥塞.而分包可以在一定程度上减轻这种情况,提高传输效率.</p><p><strong>4.组包是什么?</strong><br>在数据包进行分包后,目标主机收到的就不是一个完整的数据包了,而是许多小的数据包.将这些被分包过后的数据包进行组装恢复成为原来完成的IP数据包的过程就成为组包</p><p><strong>5.分包组包过程中和哪些 IP 报头字段有关联?</strong><br>对于分包,通俗的话来说就是讲一支完整的队伍拆成固定人数的小组进行通过.</p><p> <strong>校验和字段（Header Checksum）：</strong> 对于传输的小组中的人员,在经过时要检查小组中的人员是否与原来发出的人员一致,这时就要通过<strong>校验和</strong>来检验数据包在传输的过程中是否遭到了破坏。在 IP 数据包传输过程中，每个路由器都会重新计算这个校验和字段，以确保数据的完整性。</p><p><strong>标识符字段（Identification）:</strong> 在传输过程中,发送端发送的完整数据包并非只有一个,每发送一个数据包,报头的<strong>标识符</strong>就会+1.对于分片&#x2F;分包后的数据包,在目标主机中该怎么知道哪一些分片后的数据包该放在一堆呢?就可以通过<strong>标识符</strong>来辨别这个小组是哪一个大队伍的.</p><p> <strong>标志位字段（Flags）：</strong> 对于目标主机来说,不知道对方传来的数据包总的规格是多少,被分成了多少包.这时就可以通过标记位来辨别.对于被分片&#x2F;分包后的数据包们,只有最后一位的数据包的标记位的最后一位为0,其余的数据包的标记位的最后一位都为1.1表示为,后面还有同一个队伍的数据包要到达.0则表示我是这一组的末尾咯,后面已经没有本组的数据包了.</p><p> <strong>片偏移字段（Fragment Offset）：</strong> 数据包分片传输后,对于原来数据最重要的就是这些分段数据的顺序了.只有每一小段的数据的顺序都对的上才能重新在目标主机中恢复成原来的模样。偏移量指示当前片段在整个原始数据包中的位置。例如，偏移量为 0 的片段包含数据包的头部。</p><p> <strong>协议字段（Protocol）</strong>：协议字段用于指示 IP 数据报携带的数据的协议类型。例如，1 表示 ICMP 协议，6 表示 TCP 协议，17 表示 UDP 协议等。这个字段是在组包过程中进行处理的。</p><p><strong>6.组包时如何保证数据的顺序和完整性?</strong><br>  片偏移字段：每个 IP 片段的片偏移字段指示该片段在原始数据包中的位置。接收方可以利用这些字段将片段按照正确的顺序进行组装。</p><p>  标识符字段：每个 IP 数据包都有一个唯一的标识符字段。接收方可以利用这个字段将不同的 IP 片段与正确的数据包相匹配。</p><p>  更多片位标记：如果一个 IP 数据包被分成多个片段，则每个片段的“更多片位”标记位指示是否还有更多的 IP 片段等待接收。接收方可以利用这个标记位来确定是否已经接收到所有的 IP 片段。</p><p>  排序和重组：当接收方收到所有的 IP 片段后，需要按照片偏移字段对它们进行排序，并将它们重组为原始数据包的完整形式。</p><p>  计算校验和：当接收方重组 IP 片段时，需要重新计算 IP 报头的校验和字段以验证数据包的完整性和正确性。如果计算出的校验和与原始 IP 报头中的校验和不匹配，则表明数据包已经被损坏。</p><h3 id="3-2路由选择"><a href="#3-2路由选择" class="headerlink" title="3.2路由选择"></a>3.2路由选择</h3><p>路由选择，就是描述了IP协议（IP数据报）转发的过程</p><p>进行IP数据报转发时，每个路由器都不知道网络的“全貌”，只知道和自己相连的一些设备。这就意味着IP数据报在转发时是一个探索的过程。</p><p>网络层的数据包，每到达一个路由器，就会进行类似问路的操作，摸索前进</p><p>每一个路由器颞部都有一个“路由表”，根据IP数据包中的目的IP查找路由表</p><p>如果查到了，就直接按照路由表给定的方法，继续转发</p><p>如果没查到，就按照路由表的默认表进行转发</p><h2 id="四-数据链路层"><a href="#四-数据链路层" class="headerlink" title="四.数据链路层"></a>四.数据链路层</h2><h3 id="4-1以太网"><a href="#4-1以太网" class="headerlink" title="4.1以太网"></a>4.1以太网</h3><p>以太网，横跨数据链路层+物理层</p><p>以太网数据帧格式：帧头+载荷+帧尾  </p><p><img src="https://image.nicebao.com/luntan/202311121308403.webp" alt="image-20231112110817327"></p><ul><li>源地址和目的地址（均为6个字节）是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固<br>化的；</li><li>帧协议类型字段有三种值，分别对应IP、ARP、RARP；</li><li>帧末尾是CRC校验码</li></ul><p>MAC地址是网卡出场时写死的，每个硬件有其唯一的MAC地址，MAC地址也是溯源的途径之一。</p><p><img src="https://image.nicebao.com/luntan/202311121308404.webp" alt="image-20231112111403965"></p><blockquote><p><strong>IP地址和MAC地址各自的用途是什么？</strong></p><ul><li>IP协议立足于全局，完成整个通信过程的路径规划</li><li>以太网的MAC则是关注局部，负责相邻设备的通信过程</li></ul><p>eg：我从我家到学校，需要经历的过程如下</p><p>家里-&gt;天津站</p><p>（源IP：家，目的IP：学校 | 源mac：家，目的mac 天津站）</p><p>天津站-&gt;北京南站</p><p>（源IP：家，目的IP：学校 | 源mac：天津站，目的mac 北京南站）</p><p>北京北站-&gt;呼和浩特站</p><p>（源IP：家，目的IP：学校 | 源mac：北京北站，目的mac 呼和浩特站）</p><p>…….</p></blockquote><h3 id="4-2-APR和RAPR"><a href="#4-2-APR和RAPR" class="headerlink" title="4.2 APR和RAPR"></a>4.2 APR和RAPR</h3><p>APR和RAPR这两种协议并不传输业务数据，而是辅助转发的协议</p><p><img src="https://image.nicebao.com/luntan/202311121308405.webp" alt="image-20231112112611213"></p><blockquote><p>交换机在收到以太网数据帧时就需要进行转发。（转发过程需要根据mac地址判断数据走哪个网口）</p><p>交换机内部有一个“转发表”类似前面的“路由表”</p><p>转发表类似于hash表这样的映射，转发表主要就是通过arp协议生成的</p></blockquote><h3 id="4-3-MTU"><a href="#4-3-MTU" class="headerlink" title="4.3 MTU"></a>4.3 MTU</h3><p>MTU:数据链路层的数据包能携带的最大载荷长度</p><p><img src="https://image.nicebao.com/luntan/202311121308406.webp" alt="image-20231112113007488"></p><blockquote><ul><li>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP数据包的长度不够46字节，要<br>在后面补填充位；</li><li>最大值1500称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU；</li><li>如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU了，则需要对<br>数据包进行分片（fragmentation）</li><li>IP数据包的分包大概率是因为MTU引起的，而不是触发64kb上限引起的</li><li>不同的数据链路层标准的MTU是不同的；</li></ul></blockquote><h2 id="五-应用层"><a href="#五-应用层" class="headerlink" title="五.应用层"></a>五.应用层</h2><h3 id="5-1DNS"><a href="#5-1DNS" class="headerlink" title="5.1DNS"></a>5.1DNS</h3><p>TCP&#x2F;IP中使用IP地址来确定网络上的一台主机，但是IP地址不方便记忆，且不能表达地址组织信息，于是人们发明了域名，并通过域名系统来映射域名和IP地址  </p><p>最早的我们通过hosts文件来管理域名-IP的对应关系</p><p>现在我们通常使用DNS服务器来管理。eg 8.8.8.8 114.114.114.114……</p><p><img src="https://image.nicebao.com/luntan/202311121308407.webp" alt="image-20231112115518896"></p><h3 id="5-2NAT"><a href="#5-2NAT" class="headerlink" title="5.2NAT"></a>5.2NAT</h3><p>之前我们讨论了，IPv4协议中，IP地址数量不充足的问题<br>NAT技术当前解决IP地址不够用的主要手段，是路由器的一个重要功能；  </p><p><img src="https://image.nicebao.com/luntan/202311121308408.webp" alt="image-20231112130309027"></p><h3 id="5-3NAPT"><a href="#5-3NAPT" class="headerlink" title="5.3NAPT"></a>5.3NAPT</h3><p>那么问题来了，如果局域网内，有多个主机都访问同一个外网服务器，那么对于服务器返回的数据中，</p><p>目的IP都是相同的。那么NAT路由器如何判定将这个数据包转发给哪个局域网的主机？</p><p>这时候NAPT来解决这个问题了。使用IP+port来建立这个关联关系</p><p><img src="https://image.nicebao.com/luntan/202311121308409.webp" alt="image-20231112130351652"></p><h3 id="5-4NAT的缺陷"><a href="#5-4NAT的缺陷" class="headerlink" title="5.4NAT的缺陷"></a>5.4NAT的缺陷</h3><ul><li><p>无法从NAT外部向内部服务器建立连接；</p></li><li><p>转换表的生成和销毁都需要额外开销；</p></li><li><p>通信过程中一旦NAT设备异常，即使存在热备，所有的TCP连接也都会断开；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/post/f6491cfb.html"/>
      <url>/post/f6491cfb.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="一-UDP"><a href="#一-UDP" class="headerlink" title="一.UDP"></a>一.UDP</h2><h3 id="1-1-api"><a href="#1-1-api" class="headerlink" title="1.1 api"></a>1.1 api</h3><h4 id="1-1-1-DatagramSocket"><a href="#1-1-1-DatagramSocket" class="headerlink" title="1.1.1 DatagramSocket"></a>1.1.1 DatagramSocket</h4><p>DatagramSocket是一个Scocket对象。那么Socket又是什么呢？</p><p>我们的操作系统中，往往使用文件这样的概念来管理一些软硬件资源。我们这里的Socket文件，就是用来管理网卡的一种文件。</p><p>Java中的Socket对象，就对应了系统里的Socket文件，要进行网络通信，必须得先有Socket对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket()</span><br><span class="line">DatagramSocket(<span class="type">int</span> port)</span><br></pre></td></tr></table></figure><p>DatagramSocket有带端口和不带端口的构造方法，那么我们应该如何选择呢?</p><p>当在客户端使用时，我们往往让系统来自动分配，而在服务端时，我们往往手动指定。</p><h4 id="1-1-2-DatagramPacket"><a href="#1-1-2-DatagramPacket" class="headerlink" title="1.1.2 DatagramPacket"></a>1.1.2 DatagramPacket</h4><p>DatagramPacket表示了一个UDP数据报，代表了系统中设定的UDP数据报的二进制结构。</p><p>UDP是面向数据报的，每次进行传输，都要以UDP数据报为基本单位。</p><p>下面是DatagramPacket的几个构造方法，DatagramPacket作为UDP数据报，必然要承载一部分的数据，这就需要我们通过手动指定的byte[]作为数据存储的空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DatagramPacket</span><span class="params">(<span class="type">byte</span>[] buf, <span class="type">int</span> length,InetAddress address, <span class="type">int</span> port)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DatagramPacket</span><span class="params">(<span class="type">byte</span>[] buf, <span class="type">int</span> length)</span>    </span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><h3 id="1-2-代码示例"><a href="#1-2-代码示例" class="headerlink" title="1.2 代码示例"></a>1.2 代码示例</h3><h4 id="1-2-1echo回显服务器"><a href="#1-2-1echo回显服务器" class="headerlink" title="1.2.1echo回显服务器"></a>1.2.1echo回显服务器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> network;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UdpEchoServer</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个DatagramScocket对象</span></span><br><span class="line">    <span class="comment">//这是后续操作网卡的基础</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UdpEchoServer</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> SocketException &#123;</span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(port);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        我们在服务器和客户端中均需要创建一个Socket对象</span></span><br><span class="line"><span class="comment">        但是服务器的socket一般需要显示的指定一个端口号</span></span><br><span class="line"><span class="comment">        而客户端的socket一般不能显示指定（不显示指定时候系统会自动分配一个随机的端口）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过这个方法开启动服务器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//我们在使用socket.receive来接受数据时，需要先创建一个数据报（DatagramPacket)用来接受从网卡读取到的数据，</span></span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">requestPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>],<span class="number">4096</span>);</span><br><span class="line">            <span class="comment">//1.读取请求并解析</span></span><br><span class="line">            socket.receive(requestPacket);</span><br><span class="line">            <span class="comment">//当前完成recive之后，数据以二进制的形式存储到DatagramPacket中</span></span><br><span class="line">            <span class="comment">//要想能够把数据显示出来，还需要把二进制转成字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(requestPacket.getData(),<span class="number">0</span>, requestPacket.getLength());</span><br><span class="line">            <span class="comment">//2.由于我们此处是回显服务器，所以请求=响应。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">reponse</span> <span class="operator">=</span> process(request);</span><br><span class="line">            <span class="comment">//3.把响应写回客户端</span></span><br><span class="line">            <span class="comment">//  搞一个响应对象，DatagramPacket</span></span><br><span class="line">            <span class="comment">//  往DatagramPacket中填入刚才的数据，在通过sent返回</span></span><br><span class="line">            <span class="comment">//传入数据报,数据报长度，和请求中的地址</span></span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">reponsePacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(reponse.getBytes(),reponse.getBytes().length,requestPacket.getSocketAddress());</span><br><span class="line">            <span class="comment">//注意这个长度不可以更改成reponse.length，因为如果这个字符串的内容都是英文字符，此时字节和字符个数是一样的，但是如果包含中文就不一样了。</span></span><br><span class="line">            socket.send(reponsePacket);</span><br><span class="line">            <span class="comment">//4.打印日志</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;[%s:%d] req=%s res=%s\n&quot;</span>,reponsePacket.getAddress().toString(),reponsePacket.getPort(),request,reponse);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">process</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">UdpEchoServer</span> <span class="variable">udpEchoServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UdpEchoServer</span>(<span class="number">9090</span>);</span><br><span class="line">        udpEchoServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package network;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.*;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class UdpEchoClient &#123;</span><br><span class="line">    private DatagramSocket socket = null;</span><br><span class="line">    private String severIp = &quot;&quot;;</span><br><span class="line">    private int severPort = 0;</span><br><span class="line">    public UdpEchoClient(String severIp,int severPort) throws SocketException &#123;</span><br><span class="line">        //创建这个对象不能手动指定端口</span><br><span class="line">        socket = new DatagramSocket();</span><br><span class="line">        //由于UDP自身不回持有对端的信息，就需要在应用程序中把对端的情况记录下来。</span><br><span class="line">        this.severIp = severIp;</span><br><span class="line">        this.severPort = severPort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;客户端启动&quot;);</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //1.从控制台读取一个数据,作为请求</span><br><span class="line">            System.out.print(&quot;-&gt;&quot;);</span><br><span class="line">            String request = sc.next();</span><br><span class="line">            //2.把请求内容构造成一个DatagramPacket对象，发送给服务器</span><br><span class="line">            DatagramPacket requestPacket = new DatagramPacket(request.getBytes(),request.getBytes().length, InetAddress.getByName((severIp)), severPort);</span><br><span class="line">            socket.send(requestPacket);</span><br><span class="line">            //3.尝试读取服务器返回的响应</span><br><span class="line">            DatagramPacket responsePacket = new DatagramPacket(new byte[4096],4096);</span><br><span class="line">            socket.receive(responsePacket);</span><br><span class="line">            //4.把响应转换成字符串，并打印输出</span><br><span class="line">            String response = new String(responsePacket.getData(),0,responsePacket.getLength());</span><br><span class="line">            System.out.println(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        UdpEchoClient udpEchoClient = new UdpEchoClient(&quot;127.0.0.1&quot;,9090);</span><br><span class="line">        udpEchoClient.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-2-2-翻译服务器"><a href="#1-2-2-翻译服务器" class="headerlink" title="1.2.2 翻译服务器"></a>1.2.2 翻译服务器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> network;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UdpDictServer</span> <span class="keyword">extends</span> <span class="title class_">UdpEchoServer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; dict = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UdpDictServer</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> SocketException &#123;</span><br><span class="line"><span class="built_in">super</span>(port);</span><br><span class="line">dict.put(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;小狗&quot;</span>);</span><br><span class="line">dict.put(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;小猫&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">process</span><span class="params">(String request)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dict.get(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">UdpDictServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UdpDictServer</span>(<span class="number">9090</span>);</span><br><span class="line">server.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-2-3-总结"><a href="#1-2-3-总结" class="headerlink" title="1.2.3 总结"></a>1.2.3 总结</h4><p>1.服务器先启动，服务器启动之后，就会进入循环，找到receive并阻塞（当客户端还未传入数据时）</p><p>2.客户端启动，也会先进入while循环，执行sc.next,并且也在这里阻塞</p><pre><code>当用户在控制台输入字符串之后，next就会返回，从而构造请求数据并发送给服务器。</code></pre><p>3.客户端发送出数据之后</p><pre><code>服务器：就会从receive中返回，进一步的执行解析请求为字符串，执行process操作，执行send操作客户端：继续往下执行，执行到receive等待服务器的响应、</code></pre><p>4.客户端收到从服务器返回的数据后，就会从receive中返回</p><pre><code>执行到这里的打印操作，接着显示出响应内容</code></pre><p>5.服务器完成一次循环之后，又会执行到reveive</p><pre><code>客户端完成一次循环之后，又会执行到sc.next双双进入阻塞等待</code></pre><h2 id="2-TCP"><a href="#2-TCP" class="headerlink" title="2.TCP"></a>2.TCP</h2><h3 id="2-1-API"><a href="#2-1-API" class="headerlink" title="2.1 API"></a>2.1 API</h3><p>TCP的socketapi和UDP的socket api差异很大，接下来让我们往下看</p><h4 id="2-1-1-ServerSocket"><a href="#2-1-1-ServerSocket" class="headerlink" title="2.1.1 ServerSocket"></a>2.1.1 ServerSocket</h4><p>给服务器使用的类，用来绑定端口号</p><h4 id="2-1-2-Socket"><a href="#2-1-2-Socket" class="headerlink" title="2.1.2 Socket"></a>2.1.2 Socket</h4><p>既会给服务器用，又会给客户端使用</p><h4 id="2-1-3-对比"><a href="#2-1-3-对比" class="headerlink" title="2.1.3 对比"></a>2.1.3 对比</h4><ol><li>TPC是有<strong>连接</strong>的 UDP是无<strong>连接</strong></li><li>TCP是可靠传输 UDP是不可靠传输</li><li>TCP是面向字节流 UDP是面向数据报</li><li>TCP和 UDP都是全双工</li></ol><blockquote><p><strong>连接：通信双方是否会记录保存对端的信息。</strong></p><p>UDP：每次发送数据都需要手动在send方法中指定</p><p>TCP：连接如何建立，不需要代码干预，由系统内核自动完成</p></blockquote><p>对应用程序来说：</p><ul><li><p>客户端主要是发起“建立连接”的动作</p></li><li><p>服务器主要是<strong>把建立好的连接从内核中拿到应用程序里</strong></p></li></ul><p></p><p>如果有客户端和服务器要建立连接，这时服务器的应用程序是没有任何感知的，内核直接就完成了建立连接的流程（三次握手），完成流程之后，就会在内核的队列中（每一个ServerSocket都有这样的一个队列）排队。</p><p>应用程序要想和客户端进行通信，就需要通过一个accept方法，把内核中已经建立好的连接对象，拿到应用程序中</p><h3 id="2-2代码示例"><a href="#2-2代码示例" class="headerlink" title="2.2代码示例"></a>2.2代码示例</h3><h4 id="2-2-1代码"><a href="#2-2-1代码" class="headerlink" title="2.2.1代码"></a>2.2.1代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> network;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpEchoServer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">ServerSocket</span> <span class="variable">severSocket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TcpEchoServer</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">severSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;服务器启动&quot;</span>);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//通过accetp方法，把内核中已经建立 好的链接拿到应用中</span></span><br><span class="line"><span class="comment">//建立连接的细节流程是内核自动完成的，应用程序只需要捡现成的即可</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> severSocket.accept();</span><br><span class="line">service.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">processConnection(clientSocket);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过这个方法来处理当前的连接</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConnection</span><span class="params">(Socket clientSocket)</span>&#123;</span><br><span class="line"><span class="comment">//进入方法，打印出一个日志，表示当前有客户端连接上了</span></span><br><span class="line">System.out.printf(<span class="string">&quot;[%s:%d] 客户端上线!\n&quot;</span>, clientSocket.getInetAddress(), clientSocket.getPort());</span><br><span class="line"><span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> clientSocket.getInputStream();</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> clientSocket.getOutputStream()) &#123;</span><br><span class="line"><span class="comment">// 使用 try ( ) 方式, 避免后续用完了流对象, 忘记关闭.</span></span><br><span class="line"><span class="comment">// 由于客户端发来的数据, 可能是 &quot;多条数据&quot;, 针对多条数据, 就循环的处理.</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(inputStream);</span><br><span class="line"><span class="keyword">if</span>(!sc.hasNext())&#123;</span><br><span class="line"><span class="comment">// 连接断开了. 此时循环就应该结束</span></span><br><span class="line">System.out.printf(<span class="string">&quot;[%s:%d] 客户端下线!\n&quot;</span>, clientSocket.getInetAddress(), clientSocket.getPort());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 读取请求并解析. 此处就以 next 来作为读取请求的方式. next 的规则是, 读到 &quot;空白符&quot; 就返回.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> sc.next();</span><br><span class="line"><span class="comment">// 2. 根据请求, 计算响应.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> processs(request);</span><br><span class="line"><span class="comment">// 3. 把响应写回到客户端.</span></span><br><span class="line"><span class="comment">//    可以把 String 转成字节数组, 写入到 OutputStream</span></span><br><span class="line"><span class="comment">//    也可以使用 PrintWriter 把 OutputStream 包裹一下, 来写入字符串.</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(outputStream);</span><br><span class="line"><span class="comment">//    此处的 println 不是打印到控制台了, 而是写入到 outputStream 对应的流对象中, 也就是写入到 clientSocket 里面.</span></span><br><span class="line"><span class="comment">//    自然这个数据也就通过网络发送出去了. (发给当前这个连接的另外一端)</span></span><br><span class="line"><span class="comment">//    此处使用 println 带有 \n 也是为了后续 客户端这边 可以使用 scanner.next 来读取数据.</span></span><br><span class="line">printWriter.println(response);</span><br><span class="line"><span class="comment">//    此处还要记得有个操作, 刷新缓冲区. 如果没有刷新操作, 可能数据仍然是在内存中, 没有被写入网卡.</span></span><br><span class="line">printWriter.flush();</span><br><span class="line"><span class="comment">// 4. 打印一下这次请求交互过程的内容</span></span><br><span class="line">System.out.printf(<span class="string">&quot;[%s:%d] req=%s, resp=%s\n&quot;</span>, clientSocket.getInetAddress(), clientSocket.getPort(), request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 在这个地方, 进行 clientSocket 的关闭.</span></span><br><span class="line"><span class="comment">// processConnection 就是在处理一个连接. 这个方法执行完毕, 这个连接也就处理完了.</span></span><br><span class="line">clientSocket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processs</span><span class="params">(String request)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">TcpEchoServer</span> <span class="variable">tcpEchoServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TcpEchoServer</span>(<span class="number">9090</span>);</span><br><span class="line">tcpEchoServer.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> network;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpEchoClient</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TcpEchoClient</span><span class="params">(String serverIp,<span class="type">int</span> ServerPort)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// 需要在创建 Socket 的同时, 和服务器 &quot;建立连接&quot;, 此时就得告诉 Socket 服务器在哪里~~</span></span><br><span class="line"><span class="comment">// 具体建立连接的细节, 不需要咱们代码手动干预. 是内核自动负责的.</span></span><br><span class="line"><span class="comment">// 当我们 new 这个对象的时候, 操作系统内核, 就开始进行 三次握手 具体细节, 完成建立连接的过程了.</span></span><br><span class="line">socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(serverIp,ServerPort);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream()) &#123;</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(outputStream);</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scannerNetWork</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(inputStream);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//1.从控制台读取用户输入的内容</span></span><br><span class="line">System.out.println(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> sc.next();</span><br><span class="line"><span class="comment">// 2. 把字符串作为请求, 发送给服务器</span></span><br><span class="line"><span class="comment">//    这里使用 println, 是为了让请求后面带上换行.</span></span><br><span class="line"><span class="comment">//    也就是和服务器读取请求, scanner.next 呼应</span></span><br><span class="line">writer.println(request);</span><br><span class="line">writer.flush();</span><br><span class="line"><span class="comment">//3.读取服务器返回的相应</span></span><br><span class="line"><span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> scannerNetWork.next();</span><br><span class="line"><span class="comment">//4.输出内容</span></span><br><span class="line">System.out.println(response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">TcpEchoClient</span> <span class="variable">tcpEchoClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TcpEchoClient</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9090</span>);</span><br><span class="line">tcpEchoClient.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-注意事项"><a href="#2-2-2-注意事项" class="headerlink" title="2.2.2 注意事项"></a>2.2.2 注意事项</h4><h5 id="clientSocket需要进行close操作"><a href="#clientSocket需要进行close操作" class="headerlink" title="clientSocket需要进行close操作"></a>clientSocket需要进行close操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket clientSocket</span><br></pre></td></tr></table></figure><p>在UDP中的DatagramSocket和ServerSocket都没有写close，那为什么没问题呢？</p><p>因为UDP中的DatagramSocket和ServerSocket的周期是贯穿着整个程序的，只有这么一个对象，所以并不会频繁的创建，因此不会造成内存泄漏问题。</p><p>但是TCP中，ClientSocket是在一个循环中，每当有新的客户端来建立连接就会创建出一个新的ClienbtSocket</p><p>虽然我们已经在下面进行了trycatch操作，但这里关闭的知识clinetSocker上自带的流对象，并没有关闭socket本身</p><p><img src="https://image.nicebao.com/luntan/202310221211056.webp" alt="image-20231022121135160"></p><p>所以，我们需要在代码中，通过finally加上close，来确保socket能被正确的关闭</p><p><img src="https://image.nicebao.com/luntan/202310221219161.webp" alt="image-20231022121910772"></p><h5 id="使用线程池来建立多端连接"><a href="#使用线程池来建立多端连接" class="headerlink" title="使用线程池来建立多端连接"></a>使用线程池来建立多端连接</h5><p>为什么我们需要线程池来处理多端连接问题呢？</p><p><img src="https://image.nicebao.com/luntan/202310221320012.webp" alt="image-20231022130700601"></p><p>如图所示，图上的代码并没有使用线程池，接下来让我们分析一下问题</p><p>第一个客户端连接之后，accept就返回了，得到了一个clientSocket，进入了processConnection</p><p>接下来又进入了一个while循环，在这个循环中，需要反复处理客户端发来的请求数据，如果客户端这会还没有发送请求，服务器代码就会阻塞在sc.hasNext这里</p><p>此时此刻，第二个客户端来连接了，此时是可以连接成功的（因为连接由内核负责）建立连接之后，连接对象就会在内核的队列里等待，直到代码通过accept把连接取出来。</p><p>但是当前的代码是无法第一时间执行到第二次的accept。第一个客户端会使服务器处于processConnection内部，直到第一个客户端退出，processConnection才能结束，才能执行后续的操作。</p><p>出现这个问题的关键点在于两重循环在一个线程里，进入第二重循环的时候，无法继续执行第一个循环，UDP服务器中只有一个循环，故不会出现这个问题，所以我们应使用多线程来解决。</p><p><img src="https://image.nicebao.com/luntan/202310221320071.webp" alt="image-20231022131028252"></p><h1 id="网络原理"><a href="#网络原理" class="headerlink" title="网络原理"></a>网络原理</h1><h2 id="一-UDP-1"><a href="#一-UDP-1" class="headerlink" title="一.UDP"></a>一.UDP</h2><h3 id="1-1-UDP报文结构"><a href="#1-1-UDP报文结构" class="headerlink" title="1.1 UDP报文结构"></a>1.1 UDP报文结构</h3><p> <strong>UDP是传输层协议之一,其主要特点是无连接,不可靠传输,面向数据报,全双工</strong></p><p><img src="https://image.nicebao.com/luntan/202310262051489.webp" alt="image-20231026205157171"> </p><blockquote><p>UDP报文主体分为两个部分:UDP报头(占8个字节)+UDP数据&#x2F;UDP载荷</p><p>UPD报头:源端口号+目的端口号+数据报长度+校验和</p></blockquote><ul><li><p>源端口号和目的端口号</p><ul><li>源端口号和目的端口号均占用16个比特位，即为2个字节</li></ul></li><li><p>UDP长度</p><ul><li>总共16位,占两个字节</li><li>UDP报文长度&#x3D;UDP报头(首部)+UDP载荷</li><li>2个字节能表示的数据范围是0~65535,也就是能够表示的报文长度是65536字节(Byte),转换成KB,65536&#x2F;1024 &#x3D; 64 KB 这就是一个UDP报文所能表示的最大长度.</li></ul></li><li><p>校验和</p><ul><li>数据在传输的时候,本质上是0&#x2F;1bit流,通过光信号或者电信号来表示,如果在传输的时候收到干扰,就可能会出现比特翻转现象.这个时候就需要校验和校验数据是否出错.</li></ul></li></ul><h3 id="1-2UDP报文特点"><a href="#1-2UDP报文特点" class="headerlink" title="1.2UDP报文特点"></a>1.2UDP报文特点</h3><p><strong>1.无连接</strong></p><p>  知道对端的  IP  和端口号就直接进行传输，不需要建立连接；  </p><p><strong>2.不可靠</strong></p><p> 没有任何安全机制，发送端发送数据报以后，如果因为某些问题无法发送到对端， UDP  协议层也不会给应用层返回任何错误信息；  </p><p><strong>3.面向数据报</strong></p><p> 应用层无论交给  UDP  多大的报文，UDP原样发送，不会拆分或者合并；</p><p><strong>4.缓冲区</strong></p><p>  UDP  只有接收缓冲区，没有发送缓冲区</p><p><strong>5.大小受限</strong></p><p>  UDP  协议首部中有一个  16  位的最大长度。也就是说一个  UDP  能传输的数据最大长度是  64K  （包含 UDP首部）。  </p><h3 id="1-3-基于UDP的应用层协议"><a href="#1-3-基于UDP的应用层协议" class="headerlink" title="1.3 基于UDP的应用层协议"></a>1.3 基于UDP的应用层协议</h3><blockquote><ul><li>NFS：网络文件系统 </li><li>TFTP：简单文件传输协议 </li><li>DHCP：动态主机配置协议 </li><li>BOOTP：启动协议（用于无盘设备启动） </li><li>DNS：域名解析协议</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE多线程案例</title>
      <link href="/post/3009087b.html"/>
      <url>/post/3009087b.html</url>
      
        <content type="html"><![CDATA[<h1 id="多线程案例"><a href="#多线程案例" class="headerlink" title="多线程案例"></a><strong>多线程案例</strong></h1><h2 id="一-单例模式"><a href="#一-单例模式" class="headerlink" title="一.单例模式"></a>一.<strong>单例模式</strong></h2><h3 id="1-1单例模式介绍"><a href="#1-1单例模式介绍" class="headerlink" title="1.1单例模式介绍"></a>1.1单例模式介绍</h3><p>单例模式是一个经典的<strong>设计模式</strong></p><p>既然我们提到了设计模式，那么什么是设计模式呢？</p><p><em>设计模式，就是我们程序猿的棋谱，我们在实际开发过程中，如果遇到一些特定的经典场景，我们就可以按照这个解决方案来进行编码</em></p><blockquote><p><strong>校招中，考察的设计模式最常见的有两个</strong></p><ol><li>单例模式</li><li>工厂模式</li></ol></blockquote><p>单例模式能保证某个类在程序中只存在唯一一份实例, 而不会创建出多个实例。</p><p>在有些场景中，我们希望有的类只能有一个对象，不能有多个，这时候我们就可以使用单例模式了。</p><p>看到这里大家可能会有一个疑问：我只new一次对象不就好了吗，为什么要这么复杂？</p><h5 id="单例模式的重要性"><a href="#单例模式的重要性" class="headerlink" title="单例模式的重要性"></a>单例模式的重要性</h5><p>我们需要让编译器帮我们监督，确保这个类不会new出多个对象。如果只靠注释标明这个类不能创建多个对象那是万万不能的。</p><p>这样的思想方法，我们之前学习过的很多地方也都有涉及，比如下面这四个。</p><ul><li>final</li><li>interface</li><li>@Override</li><li>throws.</li></ul><p>但是在语法层面上，并没有对单例模式做出支持，所以我们就只能通过一些编程技巧，来达成类似的效果。</p><p>接下来我们详细介绍一下单例模式具体的实现方式, 分成 “饿汉” 和 “懒汉” 两种. </p><h3 id="1-2饿汉模式（基础）"><a href="#1-2饿汉模式（基础）" class="headerlink" title="1.2饿汉模式（基础）"></a>1.2饿汉模式（基础）</h3><h4 id="1-2-1代码描述"><a href="#1-2-1代码描述" class="headerlink" title="1.2.1代码描述"></a>1.2.1代码描述</h4><ol><li><strong>私有构造函数</strong>：类<code>Singleton</code>有一个私有构造函数，这意味着在类外部无法使用<code>new</code>关键字创建其实例。这强制要求获取<code>Singleton</code>类的唯一实例只能通过<code>getInstance</code>方法来实现。</li><li><strong>静态实例变量</strong>：该类有一个私有的静态实例变量<code>instance</code>，它保存了该类的唯一实例。它在类加载时初始化，因为它在一行中声明和实例化。</li><li><strong>静态<code>getInstance</code>方法</strong>：<code>getInstance</code>方法是公共的和静态的，允许外部代码获取<code>Singleton</code>类的唯一实例。该方法返回<code>instance</code>变量。</li></ol><h4 id="1-2-2代码实现"><a href="#1-2-2代码实现" class="headerlink" title="1.2.2代码实现"></a>1.2.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-引用测试"><a href="#1-2-3-引用测试" class="headerlink" title="1.2.3 引用测试"></a>1.2.3 引用测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2);</span><br><span class="line">        System.out.println(singleton1.equals(singleton2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.nicebao.com/luntan/202309192352590.webp" alt="image-20230919215704205"></p><p>调用代码后我们发现，singleton1和singleton2实际上引用了同一个对象。这就是Singleton模式的主要作用：确保在整个应用程序中只有一个实例，并提供一种全局的方式来访问它。</p><h3 id="1-3饱汉模式（基础）"><a href="#1-3饱汉模式（基础）" class="headerlink" title="1.3饱汉模式（基础）"></a>1.3饱汉模式（基础）</h3><h4 id="1-3-1-代码描述"><a href="#1-3-1-代码描述" class="headerlink" title="1.3.1 代码描述"></a>1.3.1 代码描述</h4><ol><li><strong>私有构造函数</strong>：类<code>SingletonLazy</code>有一个私有构造函数，这阻止了在类外部通过<code>new</code>关键字创建类的实例。</li><li><strong>静态实例变量</strong>：类中有一个私有的静态成员变量<code>INSTANCE</code>，用于存储类的唯一实例。初始时，它被设置为<code>null</code>。</li><li><strong>静态<code>getInstance</code>方法</strong>：<code>getInstance</code>方法是公共的和静态的，用于获取<code>SingletonLazy</code>类的唯一实例。在这个方法中，检查<code>INSTANCE</code>是否为<code>null</code>。如果<code>INSTANCE</code>是<code>null</code>，则创建一个新的<code>SingletonLazy</code>实例并将其分配给<code>INSTANCE</code>，然后返回该实例。如果<code>INSTANCE</code>不是<code>null</code>，则直接返回已经存在的实例。</li></ol><h4 id="1-3-2代码实现"><a href="#1-3-2代码实现" class="headerlink" title="1.3.2代码实现"></a>1.3.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonLazy</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonLazy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-引用测试"><a href="#1-3-3-引用测试" class="headerlink" title="1.3.3 引用测试"></a>1.3.3 引用测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SingletonLazy</span> <span class="variable">singletonLazy1</span> <span class="operator">=</span> SingletonLazy.getInstance();</span><br><span class="line">        <span class="type">SingletonLazy</span> <span class="variable">singletonLazy2</span> <span class="operator">=</span> SingletonLazy.getInstance();</span><br><span class="line">        System.out.println(singletonLazy1 == singletonLazy2);</span><br><span class="line">        System.out.println(singletonLazy1.equals(singletonLazy2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-线程安全问题"><a href="#1-4-线程安全问题" class="headerlink" title="1.4 线程安全问题"></a>1.4 线程安全问题</h3><p>回看我们这一章的标题<strong>”多线程“</strong>，我们来思考一下这两种写法，是否存在线程安全问题？（多个线程同时调用getinstance是否能出现问题？）</p><p>那么让我们回顾一下怎样才能构成线程安全问题；</p><blockquote><p>如果多个线程，同时修改同一个变量就可能构成线程安全问题</p><p>如果多个线程，同时读取一个变量就不会构成线程安全难问题</p></blockquote><p>看到这里，大家心里可能已经有了答案：饿汉模式没有线程安全问题、懒汉模式具有线程安全问题。</p><p>因为饿汉模式只进行了读取，没有进行修改：而懒汉模式既会读取又会修改。</p><hr><p>那么我们应该怎么做呢？<strong>加锁！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SingletonLazy.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们按照这个方式给代码加锁之后，确是能解决部分多线程修改的问题，但是一旦代码这么写，后续每次调用getinstance，都需要先加锁。但是实际上，懒汉模式中线程安全问题只出现在最开始还没有new对象的时候。一旦对象new出来了，后续多线程调用getinstance就只有读取，就不会有线程安全问题了。</p><p>所以我们应该如何修改提升代码的性能呢？</p><p>我们上面提到，懒汉模式只有在第一次new对象的时候才会加锁，那么我们可以在加锁操作前进行一次if判断，如果对象已经创建了，线程就安全了，此时就不需要加锁了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (SingletonLazy.class) &#123;</span><br><span class="line">               <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                   INSTANCE = <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> INSTANCE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一个iff用来判断是否需要加锁</p><p>第二个if用来判断是否需要new对象</p></blockquote><p>我们平常很少写出这样的语句。在这里只不过是凑巧，这俩判断是一样的写法。</p><hr><p>代码写到这里，我们还需要注意一个非常重要的问题<strong>指令重排序</strong></p><p>我们之前提到过，编译器为了提高执行效率，可能调整原代码的执行顺序。</p><p><img src="https://image.nicebao.com/luntan/202309192351685.webp" alt="image-20230919234800249"></p><p>就比如我们去超市，想买白菜→韭菜→西红柿→蒜薹</p><p>但是实际中按这样的顺序去超市购买会来来回回的跑，非常复杂。</p><p>编译器就可能帮我们优化成西红柿→蒜薹→白菜→韭菜</p><p><strong>通常情况下，指令重排序能够在保证逻辑不变的前提下，优化程序的执行速度</strong></p><p>但是在我们上面的这个代码中，就可能会出现一些问题</p><p>new操作，是可能触发指令重排序的</p><p>new操作可以拆分为散步：</p><ol><li>申请内存空间</li><li>在内存空间上构造对象（构造方法）</li><li>把内存的地址，赋值给instance引用</li></ol><p>可以按照1 2 3的顺序来执行，也可以按照1 3 2的顺序来执行。（1一定是最先执行的）</p><p>其实在单线程中哪一种执行方式都是无所谓的，但是在多线程中就会有问题了</p><h5 id="eg执行顺序①③②"><a href="#eg执行顺序①③②" class="headerlink" title="eg执行顺序①③②"></a>eg执行顺序①③②</h5><p>当线程一执行完1和3时，Instance变成非NULL了，但是Instance指向的是一个还没有初始化的对象</p><p>此时线程二开始执行，由于我们第一个<code> if(INSTANCE == null)</code>没有加锁，所以可以线程二判定instance &#x3D;&#x3D; NULL不成立，于是线程二返回INSTANCE。进一步线程二线程代码就可能访问INSTANCE里的方法和属性</p><p>所以我们针对这个代码加一个volatile即可解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingletonLazy</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="title function_">SingletonLazy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonLazy.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5阻塞队列"><a href="#1-5阻塞队列" class="headerlink" title="1.5阻塞队列"></a>1.5阻塞队列</h3><p>阻塞队列是一种特殊的队列，其最大的意义就是实现“生产者消费者模型”</p><blockquote><ol><li>线程安全</li><li>带有阻塞特性<ol><li>如果队列为空，继续出队列，就会发生阻塞，阻塞到其他线程往队列里添加元素为止</li><li>如果队列为满，继续如队列，也会发生阻塞，阻塞到其他线程从队列中取走元素为止</li></ol></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小米/华为授权店体验新机</title>
      <link href="/post/2bb2f186.html"/>
      <url>/post/2bb2f186.html</url>
      
        <content type="html"><![CDATA[<p>前几天和同学去华为和小米的授权店体验了一番，收货很大，新机确实很舒服。</p><p>先去华为体验了下新出的mate60 pro，体验确实不错，可惜对我而言太贵了，没法支持一波。</p><p>顺便看了看新出的平板，Matepad11 2023款8+128G搭载晓龙870，售价才1899，我直接震撼。</p><p>22年也就是去年，我买了一个Matepad11 2021款8+128G搭载晓龙865，售价都2899，相比之下这波血亏。但华为前两年过的也不舒服，就当支持华为吧，希望华为以后越来越来，能突破更多的技术封锁。</p><p>这次新出的平板有一个柔光屏，这个屏和外加类纸膜相比舒服很多。日常观感也还能接受，如果平常记笔记多的话，用这个应该会很舒服。</p><hr><p>逛完华为我又去小米之家溜了一圈，感觉相比华为，小米之家的人就比较少了，华为那边都是在体验和预定mate60 pro。</p><p>试了试小米13 ultra，莱卡画质确实棒，尤其是拍人像，有一种说不出的质感，非常喜欢！等以后工作做了一定要买一台试试。</p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE线程池的介绍和用法</title>
      <link href="/post/2b0ea982.html"/>
      <url>/post/2b0ea982.html</url>
      
        <content type="html"><![CDATA[<h1 id="JavaEE线程池"><a href="#JavaEE线程池" class="headerlink" title="JavaEE线程池"></a>JavaEE线程池</h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><h3 id="1-1什么是线程池"><a href="#1-1什么是线程池" class="headerlink" title="1.1什么是线程池"></a>1.1什么是线程池</h3><p>在JAVA中，虽然创建和使用一个线程非常容易，但是由于创建线程需要使用使用一定的资源，在高并发高负载的情况下，频繁的创建和销毁线程会大量小号CPU和内存资源，对程序性能会造成很大的影响，为了解决这一问题，线程池应运而生。</p><p>线程池是一种利用池化思想来实现的线程管理技术</p><p>使用类似思想的技术还有MySQL的连接池，JVM的字符串常量池等</p><p><strong>线程池最大的好处就是减少每次启动、销毁线程的损耗并且方便管理这些资源</strong></p><blockquote><p>同时，阿里巴巴在其《Java开发手册》中也强制规定：线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p></blockquote><h2 id="二-线程池的介绍"><a href="#二-线程池的介绍" class="headerlink" title="二.线程池的介绍"></a>二.线程池的介绍</h2><h3 id="2-1-线程池的创建方法"><a href="#2-1-线程池的创建方法" class="headerlink" title="2.1 线程池的创建方法"></a>2.1 线程池的创建方法</h3><p>线程池的创建方法一共有七种，但总体分为两类</p><ul><li><p>通过 <strong><code>Executors</code></strong> 工厂类创建. 创建方式比较简单, 但是定制能力有限. </p></li><li><p>通过 <strong><code>ThreadPoolExecutor</code></strong> 创建. 创建方式比较复杂, 但是定制能力强</p></li></ul><h4 id="2-1-1-如何“new”一个线程池"><a href="#2-1-1-如何“new”一个线程池" class="headerlink" title="2.1.1 如何“new”一个线程池"></a>2.1.1 如何“new”一个线程池</h4><p>那么我们如何创建一个线程池呢？</p><p>线程池对象不是咱们直接通过new来创建的。而是通过了一个称专门的方法，反回了一个线程池对象</p><p><em>下面展示了两个创建方法，图一为正确方法，图二为错误示例</em></p><p><img src="https://image.nicebao.com/luntan/202309180005580.webp" alt="image-20230917233210609"><br><img src="/./../%E5%8E%9F%E5%9B%BE/blog2023/image-20230917233232356.png" alt="image-20230917233232356"></p><p>那么，这种创建线程池的方法叫什么呢？</p><p>我们称这种方式为<strong>工厂模式(设计模式）</strong>，工厂模式是用来给构造方法填坑的，因为构造方法存在着一定的局限性。那么这种局限性是什么呢？</p><h5 id="构造方法的局限性"><a href="#构造方法的局限性" class="headerlink" title="构造方法的局限性"></a>构造方法的局限性</h5><p>我们考虑有一个类，期望使用笛卡尔坐标系来构建对象（极坐标）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> a)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>但是这两个方法并没有构成重载，就会编译失败。</p><p>很多时候我们构造一个对象希望有多种构造方式,就需要使用多个版本的构造方法来实现</p><p>但是构造方法要求方法的名字必须是类名,不同的构造方法只能通过重载来区分</p><h5 id="工厂设计模式的优势"><a href="#工厂设计模式的优势" class="headerlink" title="工厂设计模式的优势"></a>工厂设计模式的优势</h5><p>使用工厂设计模式就能解决这个问题。</p><p>使用普通的方法来代替构造方法完成初始化的工作.</p><p>普通方法就可以使用方法的名字来区分了,也就不受到重载规则的约束了.</p><h5 id="工厂设计模式的示例"><a href="#工厂设计模式的示例" class="headerlink" title="工厂设计模式的示例"></a>工厂设计模式的示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PointFactory</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">makePointByXY</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>&#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">        p.setX(X);</span><br><span class="line">        P.setY(Y);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">makePointByA</span><span class="params">(<span class="type">double</span> r,<span class="type">double</span> a)</span>&#123;</span><br><span class="line">        <span class="comment">//写一个方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2线程池的类型"><a href="#2-1-2线程池的类型" class="headerlink" title="2.1.2线程池的类型"></a>2.1.2线程池的类型</h4><p>线程池的创建方式总共包含以下 7 种（其中 6 种是通过**<code> Executors</code> **创建的，1 种是通过 **<code>ThreadPoolExecutor </code>**创建的）：</p><p><strong>其实<code>Executors</code>本质上都是对<code>ThreadPoolExecutor</code>进行的封装</strong></p><ol><li><p><strong><code>Executors.newFixedThreadPool(int nThreads)</code></strong>: 创建一个固定大小的线程池，可以控制并发的线程数，超出的任务会在队列中等待。</p></li><li><p><strong><code>Executors.newCachedThreadPool()</code></strong>: 创建一个可缓存的线程池，如果线程数超过处理所需，会缓存一段时间后回收多余的线程，如果线程数不够，则新建线程。</p></li><li><p><strong><code>Executors.newSingleThreadExecutor()</code></strong>: 创建一个单个线程的线程池，保证任务按照先进先出的顺序执行。</p></li><li><p><strong><code>Executors.newScheduledThreadPool(int corePoolSize)</code></strong>: 创建一个可以执行延迟任务的线程池，用于定时执行任务。</p></li><li><p><strong><code>Executors.newSingleThreadScheduledExecutor()</code></strong>: 创建一个单线程的可以执行延迟任务的线程池，也用于定时执行任务。</p></li><li><p><strong><code>Executors.newWorkStealingPool()</code></strong>: 创建一个工作窃取线程池，允许任务执行的顺序不确定，通常用于高度并发的场景。这个方法是在 JDK 1.8 中引入的。</p></li><li><p>**<code>ThreadPoolExecutor</code>**：最原始的创建线程池的方式，它包含了 7 个参数可供设置</p></li></ol><p><strong>单线程池的意义：</strong> 虽然 <strong><code>newSingleThreadExecutor</code></strong> 和**<code>newSingleThreadScheduledExecutor**</code> **是单线程池，但提供了工作队列，生命周期管理，工作线程维护等功能。</p><h3 id="2-2-ThreadPoolExecutor"><a href="#2-2-ThreadPoolExecutor" class="headerlink" title="2.2 ThreadPoolExecutor"></a>2.2 ThreadPoolExecutor</h3><h4 id="2-2-1创建方式"><a href="#2-2-1创建方式" class="headerlink" title="2.2.1创建方式"></a>2.2.1创建方式</h4><p>首先，我们看一下最原始创建线程池的方式**<code>ThreadPoolExecutor</code>**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">100</span>,TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(index + <span class="string">&quot; 线程名:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2参数介绍"><a href="#2-2-2参数介绍" class="headerlink" title="2.2.2参数介绍"></a>2.2.2参数介绍</h4><p>ThreadPoolExecutor 最多可以设置 7 个参数：</p><p><img src="https://image.nicebao.com/luntan/202309180005826.webp" alt="image-20230917173402542"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><p>接下来我们详细看一下七个参数具体代表什么</p><ol><li><p><strong>corePoolSize：</strong>核心线程数，线程池中始终存活的线程数。</p><p>or：正式员工的数量. (正式员工, 一旦录用, 永不辞退)</p></li><li><p><strong>maximumPoolSize：</strong> 最大线程数，线程池中允许的最大线程数，<strong>当线程池的任务队列满了之后</strong>可以创建的最大线程数。</p><p>or：正式员工 + 临时工的数目. (临时工: 一段时间不干活, 就被辞退). </p></li><li><p><strong>keepAliveTime：</strong>最大线程数可以存活的时间，当线程中没有任务执行时，最大线程就会销毁一部分，最终保持核心线程数量的线程。</p><p>or：临时工允许的空闲时间. </p></li><li><p><strong>unit：</strong>单位是和参数 3 存活时间配合使用的，合在一起用于设定线程的存活时间。参数 keepAliveTime 的时间单位有以下 7 种可选：</p><ul><li>TimeUnit.DAYS：天</li><li>TimeUnit.HOURS：小时</li><li>TimeUnit.MINUTES：分</li><li>TimeUnit.SECONDS：秒</li><li>TimeUnit.MILLISECONDS：毫秒</li><li>TimeUnit.MICROSECONDS：微妙</li><li>TimeUnit.NANOSECONDS：纳秒</li></ul></li><li><p><strong>workQueue：</strong>阻塞队列，用来存储线程池等待执行的任务，均为线程安全。它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列几种，包含以下 7 种类型：</p><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列，即直接提交给线程不保持它们。</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列，只有在延迟期满时才能从中提取元素</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。与SynchronousQueue类似，还含有非阻塞方法。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><blockquote><p>较常用的是 <code>LinkedBlockingQueue</code> 和 <code>Synchronous</code>，线程池的排队策略与 BlockingQueue 有关</p></blockquote></li><li><p><strong>threadFactory：</strong>创建线程的工厂, 参与具体的创建线程工作. </p></li><li><p><strong>handler：</strong>拒绝策略，拒绝处理任务时的策略，系统提供了 4 种可选：</p><p>or：拒绝策略, 如果任务量超出公司的负荷了接下来怎么处理. </p><ul><li><p>AbortPolicy：超过负荷, 直接抛出异常. </p></li><li><p>CallerRunsPolicy：调用者负责处理</p></li><li><p>DiscardOldestPolicy：丢弃队列中最老的任务. </p></li><li><p>DiscardPolicy：丢弃新来的任务.</p></li></ul></li></ol><blockquote><p>默认策略为 AbortPolicy</p></blockquote><h4 id="2-2-3线程池执行流程"><a href="#2-2-3线程池执行流程" class="headerlink" title="2.2.3线程池执行流程"></a>2.2.3线程池执行流程</h4><p>ThreadPoolExecutor 关键节点的执行流程如下：</p><ol><li><p>当线程数小于核心线程数时，创建线程。</p></li><li><p>当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。</p></li><li><p>当线程数大于等于核心线程数，且任务队列已满：若线程数小于最大线程数，创建线程；若线程数等于最大线程数，抛出异常，拒绝任务。</p><p><img src="https://image.nicebao.com/luntan/202309180005197.webp" alt="image-20230917194453623"></p></li></ol><h3 id="2-3-Executors-newFixedThreadPool"><a href="#2-3-Executors-newFixedThreadPool" class="headerlink" title="2.3 Executors.newFixedThreadPool"></a>2.3 Executors.newFixedThreadPool</h3><p>**<code>FixedThreadPool</code>**：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待</p><p><img src="https://image.nicebao.com/luntan/202309180005225.webp" alt="image-20230917173319228"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>corePoolSize</strong> 与 <strong>maximumPoolSize</strong> 相等均为<strong>nThreads</strong>即为线程池大小固定</li><li><strong>keepAliveTime</strong> &#x3D; 0 该参数默认对核心线程无效，而 <code>FixedThreadPool</code> 全部为核心线程；</li><li><strong>workQueue</strong> 为 <code>LinkedBlockingQueue</code>（无界阻塞队列），队列最大值为 <code>Integer.MAX_VALUE</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        threadPool.submit(runnable);</span><br><span class="line">        threadPool.submit(runnable);</span><br><span class="line">        threadPool.submit(runnable);</span><br><span class="line">        threadPool.submit(runnable);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码：创建了一个有2个线程的线程池，但一次给它分配了4个任务，每次只能执行2个任务，所以，得执行两次。</p><blockquote><p>注：<code>submit()</code> 方法和 <code>execute()</code> 方法都是执行任务的方法。它们的区别是：<code>submit()</code> 方法有返回值，而 <code>execute()</code> 方法没有返回值。</p></blockquote><h5 id="在这里我们又引出了一个问题-线程数量设置多少最为合适呢"><a href="#在这里我们又引出了一个问题-线程数量设置多少最为合适呢" class="headerlink" title="在这里我们又引出了一个问题,线程数量设置多少最为合适呢?"></a>在这里我们又引出了一个问题,线程数量设置多少最为合适呢?</h5><p>其实这个问题网上有很多回答,但无论说什么,那都是不正确的.</p><p>因为在没有接触到实际项目的代码之前,是无法确定的.</p><p>一个线程执行的代码主要有两类:</p><ol><li>CPU密集型,代码里主要的逻辑实在进行算术运算&#x2F;逻辑判断</li><li>IO密集型,代码里主要进行IO操作</li></ol><p>假设一个线程的所有代码都是 cpu 密集型代码,这个时候,线程池的数量不应该超过 N设置的比 N 更大,这个时候,也无法提高效率了.(cpu 负载满了)此时更多的线程反而增加调度的开销<br>假设一个线程的所有代码都是 IO密集的.这个时候不吃 CPU,此时设置的线程数，就可以是超过 N.较大的值个核心可以通过调度的方式,来并发执行</p><p><strong>代码不同,线程池的线程数目设置就不同.</strong><br><strong>无法知道一个代码,具体多少内容是 cpu 密集,多少内容是 IO 密集.</strong></p><h3 id="2-4-Executors-newCachedThreadPool"><a href="#2-4-Executors-newCachedThreadPool" class="headerlink" title="2.4 Executors.newCachedThreadPool"></a>2.4 Executors.newCachedThreadPool</h3><p>**<code>CachedThreadPool</code>**：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。</p><p><img src="https://image.nicebao.com/luntan/202309180005575.webp" alt="image-20230917173228591"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize &#x3D; 0，maximumPoolSize &#x3D; Integer.MAX_VALUE，即线程数量几乎无限制；</li><li>keepAliveTime &#x3D; 60s，线程空闲 60s 后自动结束</li><li>workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为 CachedThreadPool 线程创建无限制，不会有队列等待，所以使用 SynchronousQueue</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-5-Executors-newSingleThreadExecutor"><a href="#2-5-Executors-newSingleThreadExecutor" class="headerlink" title="2.5 Executors.newSingleThreadExecutor"></a>2.5 Executors.newSingleThreadExecutor</h3><p>**<code>SingleThreadExecutor:</code>**创建单个线程数的线程池，它可以保证先进先出的执行顺序。</p><p><img src="https://image.nicebao.com/luntan/202309180005474.webp" alt="image-20230917173252241"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>corePoolSize</strong> &#x3D; 1，<strong>maximumPoolSize</strong> &#x3D; 1，即线程数量只能为1；</li><li><strong>keepAliveTime</strong> &#x3D; 0</li><li><strong>workQueue</strong> 为 **<code>LinkedBlockingQueue</code>**（无界阻塞队列），队列最大值为 1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(count + <span class="string">&quot;:任务被执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-6-Executors-newScheduledThreadPool"><a href="#2-6-Executors-newScheduledThreadPool" class="headerlink" title="2.6 Executors.newScheduledThreadPool"></a>2.6 Executors.newScheduledThreadPool</h3><p>**<code>ScheduledThreadPool</code>**：创建一个可以执行延迟任务的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 安排任务在一定的延迟后执行</span></span><br><span class="line">        scheduledExecutorService.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task 1 executed at: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 安排任务在固定的时间间隔内重复执行</span></span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task 2 executed at: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在此示例中，Task 1将在2秒后执行一次，而Task 2将每隔5秒执行一次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待一段时间后关闭ScheduledExecutorService</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.nicebao.com/luntan/202309180005894.webp" alt="image-20230917174505291"></p><h3 id="2-7-newSingleThreadScheduledExecutor"><a href="#2-7-newSingleThreadScheduledExecutor" class="headerlink" title="2.7 newSingleThreadScheduledExecutor"></a>2.7 newSingleThreadScheduledExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">singleThreadScheduledExecutor</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 安排任务在一定的延迟后执行</span></span><br><span class="line">        singleThreadScheduledExecutor.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task 1 executed at: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 安排任务在固定的时间间隔内重复执行</span></span><br><span class="line">        singleThreadScheduledExecutor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task 2 executed at: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在此示例中，Task 1将在2秒后执行一次，而Task 2将每隔5秒执行一次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待一段时间后关闭SingleThreadScheduledExecutor</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.nicebao.com/luntan/202309180005746.webp" alt="image-20230917174914894"></p><h3 id="2-8-newWorkStealingPool"><a href="#2-8-newWorkStealingPool" class="headerlink" title="2.8 newWorkStealingPool"></a>2.8 newWorkStealingPool</h3><p>**<code>NewWorkStealingPoo0l</code>**：创建一个抢占式执行的线程池（任务执行顺序不确定），注意此方法只有在 JDK 1.8+ 版本中才能使用。它是一种特殊类型的线程池，适用于处理计算密集型任务。工作窃取线程池会自动将任务分配给可用线程，并允许线程之间窃取任务以保持高效的利用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建工作窃取线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newWorkStealingPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交一些任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; started  &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="comment">// 模拟任务执行</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; completed  &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待一段时间，以确保任务有足够的时间完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.nicebao.com/luntan/202309180005607.webp" alt="image-20230917192045189"></p><h2 id="二-任务队列"><a href="#二-任务队列" class="headerlink" title="二.任务队列"></a>二.任务队列</h2><p>在上面2.2.2中的workQueue里，我们提到一共有七种任务队列。通常使用这三种任务队列，即直接提交队列（SynchronousQueue）、有界任务队列（ArrayBlockingQueue）和无界任务队列（LinkedBlockingQueue），接下来我们详细介绍下这三种队列。</p><ol><li><strong>直接提交队列 (SynchronousQueue)</strong>:<ul><li>这是一个没有容量的队列，它用于在线程池的任务提交和执行之间的直接传递。</li><li>每次提交一个任务，都会尝试立即执行它，如果没有空闲线程，则会尝试创建新线程。</li><li>如果已经有线程数达到 <code>maximumPoolSize</code>，而且队列没有足够的空间，那么线程池将拒绝接收新的任务并且采取拒绝策略（例如抛出异常）。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;());</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>有界任务队列 (ArrayBlockingQueue)</strong>:<ul><li>这是一个有容量限制的队列，它用于缓存等待执行的任务。</li><li>当线程池的线程数量小于 <code>corePoolSize</code> 时，新任务会创建新线程并立即执行。</li><li>当线程池的线程数量达到 <code>corePoolSize</code> 时，新任务会被放入队列中等待执行。</li><li>如果队列已满，但线程数还未达到 <code>maximumPoolSize</code>，那么将会创建新线程来执行任务。</li><li>如果线程数已经达到 <code>maximumPoolSize</code>，则根据设置的拒绝策略处理新的任务。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>无界任务队列 (LinkedBlockingQueue)</strong>:<ul><li>这是一个无限容量的队列，它用于缓存等待执行的任务。</li><li>线程池的线程数量将保持在 <code>corePoolSize</code> 的数量，不会超过。</li><li>新任务会被放入队列中等待执行，而不会创建超出 <code>corePoolSize</code> 的新线程。</li><li><code>maximumPoolSize</code> 参数在这种情况下是无效的，因为线程数不会超过 <code>corePoolSize</code>。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure><p>选择适当的任务队列类型取决于你的应用程序需求和性能要求。如果你需要精确控制线程数和任务执行，有界队列可能更合适。如果你想最大程度地利用系统资源，无界队列可能更适合。直接提交队列通常在需要立即执行任务的情况下使用。要记住，不同的任务队列类型可能会影响到线程池的行为和性能，所以需要根据具体的场景来选择。</p><h2 id="四-线程拒绝策略"><a href="#四-线程拒绝策略" class="headerlink" title="四.线程拒绝策略"></a>四.线程拒绝策略</h2><p>当使用线程池来管理并发任务时，有时候任务提交的速度可能会超过线程池的处理能力，这时就需要一种机制来处理这种情况。线程池的拒绝策略（Rejection Policy）提供了一种处理方式，用于定义当任务无法被接受和处理时应该采取的措施。</p><p>在 Java 中，线程池的拒绝策略由 <code>RejectedExecutionHandler</code> 接口定义，它有几种内置的实现，常见的包括：</p><ol><li><p><strong>AbortPolicy（抛弃策略）</strong>：这是默认的拒绝策略，当任务无法被接受时，会抛出 <code>RejectedExecutionException</code> 异常。</p></li><li><p><strong>CallerRunsPolicy（调用者运行策略）</strong>：当任务无法被接受时，会在当前线程中执行该任务，而不会抛出异常。这样可以降低任务提交者的速度，但可能会影响到整体性能。</p></li><li><p><strong>DiscardPolicy（丢弃策略）</strong>：当任务无法被接受时，将简单地丢弃该任务，不做任何处理。</p></li><li><p><strong>DiscardOldestPolicy（丢弃最旧策略）</strong>：当任务无法被接受时，会丢弃队列中最旧的任务，然后尝试重新提交当前任务。</p></li></ol><p>让我们结合一个示例来深入了解这些拒绝策略的工作方式。我们使用 <code>ThreadPoolExecutor</code> 类来创建一个线程池，并演示使用不同的拒绝策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolRejectionPolicyDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池，核心线程数为1，最大线程数为1，队列容量为1</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置拒绝策略为 CallerRunsPolicy</span></span><br><span class="line">        threadPool.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前任务被执行, 执行时间: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>() +</span><br><span class="line">                    <span class="string">&quot; 执行线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启4个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.nicebao.com/luntan/202309180005043.webp" alt="image-20230917193407171"></p><p>在上面的示例中，我们创建了一个核心线程数和最大线程数都为1的线程池，并将队列容量设置为1。这意味着线程池最多只能同时执行一个任务，同时任务队列只能容纳一个等待执行的任务。</p><p>然后，我们将拒绝策略设置为 <code>CallerRunsPolicy</code>，这意味着当有任务无法被接受时，当前线程（任务提交者的线程）将运行该任务，而不会抛出异常。</p><p>最后，我们提交了4个任务给线程池，但由于线程池的容量有限，只有一个任务能够立即执行，其余的任务将被线程池按照拒绝策略处理。在这个示例中，我们看到被拒绝的任务被调用者线程（主线程）执行，而不是抛出异常。</p><h2 id="五-自定义拒绝策略"><a href="#五-自定义拒绝策略" class="headerlink" title="五.自定义拒绝策略"></a>五.自定义拒绝策略</h2><p>自定义拒绝策略需要实现 <strong><code>RejectedExecutionHandler</code></strong> 接口，该接口有一个方法 **<code>rejectedExecution</code>**，在任务被拒绝执行时被调用。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo9</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义拒绝策略的处理逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务被拒绝执行：&quot;</span> + r.toString());</span><br><span class="line">        <span class="comment">// 可以根据需求执行其他操作，例如记录日志、重新提交任务等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者可以这样使用匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RejectedExecutionHandler</span> <span class="variable">customRejectionHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义拒绝策略的处理逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务被拒绝执行：&quot;</span> + r.toString());</span><br><span class="line">        <span class="comment">// 在这里你可以执行自定义的处理操作，比如记录日志或重新提交任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么如何把自定义拒绝策略应用到我们的线程池呢？</p><p>我们只需要在最后加入我们的自定义策略名称即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">2</span>,             <span class="comment">// 核心线程数</span></span><br><span class="line">            <span class="number">4</span>,             <span class="comment">// 最大线程数</span></span><br><span class="line">            <span class="number">10</span>,            <span class="comment">// 线程空闲时间</span></span><br><span class="line">            TimeUnit.SECONDS, <span class="comment">// 时间单位</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">2</span>), <span class="comment">// 任务队列容量为2</span></span><br><span class="line">            customRejectionHandler <span class="comment">// 自定义拒绝策略</span></span><br><span class="line">        );</span><br></pre></td></tr></table></figure><h2 id="六-模拟实现线程池"><a href="#六-模拟实现线程池" class="headerlink" title="六.模拟实现线程池"></a>六.模拟实现线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPool</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>); <span class="comment">// 1000 是队列的容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(Runnable runnable)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        queue.put(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadPool</span><span class="params">(<span class="type">int</span> n   )</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">runnable</span>  <span class="operator">=</span> queue.take();</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThreadPool</span> <span class="variable">myThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadPool</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            myThreadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行任务：&quot;</span> + id);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中,不知道大家有没有注意到一个问题,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">          myThreadPool.submit(() -&gt; &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;执行任务：&quot;</span> + id);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>在这个代码里打印执行任务时,没有直接使用i,而是新创建了一个id来表示i.</p><p>这是因为i是在匿名内部类中的,但是部落了外部变量中的i</p><p>变量捕获只能捕获final,所以我们需要新建一个id,就能让其捕获的是ID不是I了</p><h2 id="七-如何选择线池"><a href="#七-如何选择线池" class="headerlink" title="七.如何选择线池"></a>七.如何选择线池</h2><p>我们来看看阿里巴巴《Java开发手册》中给我们的答案：</p><blockquote><p>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors各个方法的弊端：</p><p>1）newFixedThreadPool和newSingleThreadExecutor:<br>  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。<br>2）newCachedThreadPool和newScheduledThreadPool:<br>  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p></blockquote><p>所以，综上情况所述，我们推荐使用 **<code>ThreadPoolExecutor</code> **的方式进行线程池的创建，因为这种创建方式更可控，并且更加明确了线程池的运行规则，可以规避一些未知的风险。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE线程安全问题</title>
      <link href="/post/c0397dc5.html"/>
      <url>/post/c0397dc5.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><h2 id="一-线程不安全问题举例"><a href="#一-线程不安全问题举例" class="headerlink" title="一. 线程不安全问题举例"></a>一. 线程不安全问题举例</h2><h3 id="1-多线程购票程序示例"><a href="#1-多线程购票程序示例" class="headerlink" title="1. 多线程购票程序示例"></a>1. 多线程购票程序示例</h3><p>下面是一个简单的多线程购票程序，使用两个线程模拟两个用户进行购票的操作，我们来看一下结果如何。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketSellingDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticketCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (ticketCount &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第：&quot;</span> + ticketCount++ + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (ticketCount &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第：&quot;</span> + ticketCount++ + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.nicebao.com/luntan/202309092248137.webp" alt="image-20230909203809937"></p><p>结果是两个窗口卖出了同一张票，这并不符合预期，因为两个线程同时操作一个共享变量时，会涉及线程安全问题。</p><h3 id="2-线程可见性问题示例"><a href="#2-线程可见性问题示例" class="headerlink" title="2. 线程可见性问题示例"></a>2. 线程可见性问题示例</h3><p>让我们来看另一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisibilityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">isQuit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (isQuit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环体啥也没干</span></span><br><span class="line">                <span class="comment">// 意味着执行速度极快，一秒钟会执行很多次</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t线程执行完毕&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        isQuit = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;main线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.nicebao.com/luntan/202309092257083.webp" alt="image-20230909225754676"></p><p>结果是：flag 的值已经不为0，但是t线程还没有执行结束，因为t线程读取flag时读的是寄存器中的0。</p><p>那么为什么会出现上面的问题呢？我们来继续分析。</p><h2 id="二-线程安全"><a href="#二-线程安全" class="headerlink" title="二. 线程安全"></a>二. 线程安全</h2><p>在多线程环境下，如果代码运行的结果与在单线程环境下的预期结果一致，那么我们可以说这个程序是线程安全的。线程安全问题通常涉及对共享变量的并发访问。</p><ul><li>如果所有操作都是读操作，也就是不修改变量的值，通常不存在线程安全问题。</li><li>如果至少有一个操作是写操作，那么就可能存在线程安全问题。</li></ul><h2 id="三-线程不安全的原因"><a href="#三-线程不安全的原因" class="headerlink" title="三. 线程不安全的原因"></a>三. 线程不安全的原因</h2><p>要考虑线程安全问题，就需要先考虑 <strong>Java 并发的三大基本特性</strong>：<strong>原子性</strong>、<strong>可见性</strong>以及<strong>有序性</strong>。</p><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h3><p>原子性指的是一组操作（一行或多行代码）是不可拆分的最小执行单位，这表示这组操作是具有原子性的。</p><p>当多个线程并发并行地对一个共享变量进行操作时，如果这些操作不是原子性的，就会导致线程不安全。</p><ol><li>我们对第一个例子进行分析：</li></ol><p><img src="https://image.nicebao.com/luntan/202309092358525.webp" alt="image-20230909223247524"></p><p>这最终导致的结果是一张票被售卖了两次，这样就具有很大的风险性。</p><ol start="2"><li>再举个典型的例子：n++ 和 n– 操作。</li></ol><p><img src="https://image.nicebao.com/luntan/202309092248921.webp" alt="image-20230909224614252"></p><p>经过一次 n++ 和 n– 操作后，结果并不等于预期的0，而是随机等于1或-1。</p><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h3><p>可见性指的是一个线程对共享变量值的修改能够及时被其他线程看到。多个线程在工作时都会在自己的工作内存中（CPU 寄存器）执行操作，线程之间不可见。</p><ol><li>共享变量存在于主内存中。</li><li>每个线程都有自己的工作内存。</li><li>线程读取共享变量时，会先将变量从主内存拷贝到自己的工作内存（寄存器），然后从工作内存（寄存器）中读取数据。</li><li>线程修改共享变量时，会先修改自己工作内存中的变量值，然后将修改同步到主内存。</li></ol><p>我们来对一开始举的第二个例子进行分析：</p><p><img src="https://image.nicebao.com/luntan/202309111720642.webp" alt="image-20230911172055438"></p><h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h3><p>一段代码是这样的：</p><ol><li>去前台取下 U 盘</li><li>去教室写 10 分钟作业</li><li>去前台取下快递</li></ol><p>如果是在单线程情况下，JVM、CPU 指令集会对其进行优化，比如，按 1-&gt;3-&gt;2 的方式执行，也是没问题的，可以少跑一次前台。这种叫</p><p>做指令重排序。</p><p>程序执行的顺序按照代码的先后顺序执行，在多线程编程时就得考虑这个问题。</p><h2 id="四-解决线程不安全问题"><a href="#四-解决线程不安全问题" class="headerlink" title="四. 解决线程不安全问题"></a>四. 解决线程不安全问题</h2><p>解决办法：使用多线程之间使用 <strong>关键字 synchronized</strong>、或者使用 <strong>锁（lock）</strong>，或者 <strong>volatile 关键字</strong>。</p><p><strong>① synchronized</strong>（自动锁，锁的创建和释放都是自动的）；</p><p><strong>② lock 手动锁</strong>（手动指定锁的创建和释放）。</p><p><strong>③ volatile 关键字</strong></p><h3 id="4-1-synchronized-关键字"><a href="#4-1-synchronized-关键字" class="headerlink" title="4.1 synchronized 关键字"></a>4.1 synchronized 关键字</h3><ol><li><p>直接修饰普通方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="comment">// 同步代码块</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure></li><li><p>修饰代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步代码块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>锁类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class) &#123;</span><br><span class="line">            <span class="comment">// 同步代码块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>synchronized 是基于对象头加锁的，特别注意：不是对代码加锁，所说的加锁操作就是给这个对象的对象头里设置了一个标志位。</li><li>一个对象在同一时间只能有一个线程获取到该对象的锁。</li><li>synchronized 保证了原子性，可见性，有序性（这里的有序不是指指令重排序，而是具有相同锁的代码块按照获取锁的顺序执行）。</li></ul><ol><li><p>互斥</p><p>synchronized 会起到互斥效果，某个线程执行到某个对象的 synchronized 中时，其他线程如果也执行到同一个对象的 synchronized 就会阻塞等待。</p><p>进入 synchronized 修饰的代码块，相当于加锁，</p><p>退出 synchronized 修饰的代码块，相当于解锁。</p><p>可以粗略理解为，每个对象在内存中存储的时候，都存有一块内存表示当前的 “锁定” 状态（类似于厕所的 “有人&#x2F;无人”）。如果当前是 “无人” 状态，那么就可以使用，使用时需要设为 “有人” 状态。如果当前是 “有人” 状态，那么其他人无法使用，只能排队。</p></li><li><p>刷新内存</p><p><strong>synchronized 的工作过程：</strong></p><ul><li>获得互斥锁</li><li>从主存拷贝最新的变量到工作内存</li><li>对变量执行操作</li><li>将修改后的共享变量的值刷新到主存</li><li>释放互斥锁</li></ul><p>所以 synchronized 也能保证内存可见性.</p></li><li><p>可重入</p><p>synchronized 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。</p><p>可重入锁内部会记录当前的锁被哪个线程占用，同时也会记录一个加“锁次数”，对于第一次加锁，记录当前申请锁的线程并且次数加一，但是后续该线程继续申请加锁的时候，并不会真正加锁，而是将记录的“加锁次数加1”，后续释放锁的时候，次数减1，直到次数减为0才是真的释放锁。</p><p>可重入锁的意义就是降低程序员负担（使用成本来提高开发效率），代价就是程序的开销增大（维护锁属于哪个线程，并且加减计数，降低了运行效率）。</p></li></ol><h3 id="2-volatile-关键字"><a href="#2-volatile-关键字" class="headerlink" title="2. volatile 关键字"></a>2. volatile 关键字</h3><ol><li><p>volatile 用来修饰变量，它的作用是保证可见性，有序性。<br>注意：不能保证原子性，对 n++、n– 来说，用 volatile 修饰 n 也是线程不安全的。</p></li><li><p>volatile 和 synchronized 有着本质的区别. synchronized 能够保证原子性, volatile 保证的是内存可见</p></li></ol><p> 性. </p><p>我们使用 volatile 关键字来修改第一个示例代码来看一下效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisibilityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">isQuit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (isQuit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环体啥也没干</span></span><br><span class="line">                <span class="comment">// 意味着执行速度极快，一秒钟会执行很多次</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t线程执行完毕&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        isQuit = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;main线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.nicebao.com/luntan/202309111754080.webp" alt="image-20230911175435931"></p><p> 前面我们讨论内存可见性时说了, 直接访问工作内存(实际是 CPU 的寄存器或者 CPU 的缓存), 速度</p><p>非常快, 但是可能出现数据不一致的情况. </p><p>加上 volatile , 强制读写内存. 速度是慢了, 但是数据变的更准确了. </p><p><strong>代码在写入 volatile 修饰的变量的时候</strong></p><ul><li><p>改变线程工作内存中 volatile 变量副本的值</p></li><li><p>将改变后的副本的值从工作内存刷新到主内存</p></li></ul><p><strong>代码在读取 volatile 修饰的变量的时候</strong></p><ul><li><p>从主内存中读取 volatile 变量的最新值到线程的工作内存中</p></li><li><p>从工作内存中读取 volatile 变量的副本</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐一款仿终端个人主页[详细介绍如何安装]</title>
      <link href="/post/8b08ec5a.html"/>
      <url>/post/8b08ec5a.html</url>
      
        <content type="html"><![CDATA[<p>今天我要和大家分享一个非常好看的仿终端个人主页  <a href="https://i.33mc.cn/">预览站链接</a></p><p>首先，项目的GitHub地址：<a href="https://github.com/Tomotoes/react-terminal">Tomotoes&#x2F;react-terminal: 🍳A terminal emulator in React.</a></p><p>接下来，我将详细介绍如何使用宝塔面板来安装这个程序。</p><h3 id="一-准备环境"><a href="#一-准备环境" class="headerlink" title="一. 准备环境"></a>一. 准备环境</h3><ol><li><p>打开宝塔面板的<strong>软件商店</strong>，下载并安装 Node.js。</p><p><img src="https://image.nicebao.com/luntan/202308260334003.webp" alt="软件商店截图"></p></li><li><p>打开<strong>Node.js管理器</strong>，切换到命令行版本。</p><p><img src="https://image.nicebao.com/luntan/202308260334279.webp" alt="Node.js管理器截图"></p></li></ol><p>基础环境准备完毕。</p><h3 id="二-拉取项目"><a href="#二-拉取项目" class="headerlink" title="二. 拉取项目"></a>二. 拉取项目</h3><ol><li><p>在面板左侧点击<strong>文件</strong>，在<strong>wwwroot</strong>路径下新建一个文件夹。</p></li><li><p>进入新建的文件夹，点击<strong>终端</strong>。</p><p><img src="https://image.nicebao.com/luntan/202308260334266.webp" alt="终端截图"></p></li><li><p>切换为宝塔镜像源。在终端中执行以下命令，切换为淘宝镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>查看当前使用的镜像地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p><img src="https://image.nicebao.com/luntan/202308260334109.webp" alt="切换镜像截图"></p></li><li><p>安装 Yarn，你可以使用以下命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure><p>验证安装是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn --version</span><br></pre></td></tr></table></figure></li><li><p>拉取项目源码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Tomotoes/react-terminal.git</span><br></pre></td></tr></table></figure><p><img src="https://image.nicebao.com/luntan/202308260334548.webp" alt="拉取项目截图"></p><p>当然，也可以从GitHub下载项目，然后手动上传到这个目录。</p></li><li><p>进入刚刚拉取的源码文件夹，删除两个 lock 文件。</p><p><img src="https://image.nicebao.com/luntan/202308260334561.webp" alt="删除文件截图"></p></li><li><p>在当前目录继续执行以下命令，安装项目所需的依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-terminal-app</span><br></pre></td></tr></table></figure><p>当然，你也可以使用 npm 安装，不过推荐使用 yarn：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-terminal-app</span><br></pre></td></tr></table></figure></li></ol><p>三.</p><ol><li><p>点击<strong>网站</strong>，打开 Node 项目并添加一个新的 Node 项目。</p><p><img src="https://image.nicebao.com/luntan/202308260334054.webp" alt="添加新项目截图"></p></li><li><p>如果添加成功且没有报错，点击启动选项，然后选择“启动”。</p><p><img src="https://image.nicebao.com/luntan/202308260334580.webp" alt="启动选项截图"></p></li><li><p>切换到启动选项后，重启一下服务。</p><p><img src="https://image.nicebao.com/luntan/202308260334925.webp" alt="重启服务截图"></p></li><li><p>访问你的 IP 地址加上端口号 3000，你应该能看到项目已经成功运行。</p></li></ol><h3 id="四-外网映射"><a href="#四-外网映射" class="headerlink" title="四.外网映射"></a>四.外网映射</h3><ol><li><p>添加一个域名，打开外网映射。</p><p><img src="https://image.nicebao.com/luntan/202308260334382.webp" alt="添加域名截图"></p></li><li><p>当你访问域名时，可能会出现“Invalid Host header”错误。</p></li><li><p>接下来，我们来解决这个问题。</p><ol><li><p>在项目根目录创建一个名为 <code>webpack.config.js</code> 的文件，并添加以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...其他配置</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">disableHostCheck</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 其他 devServer 配置...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>修改 <code>nbw.config.js</code> 文件，添加以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;react-component&#x27;</span>,</span><br><span class="line">  <span class="attr">npm</span>: &#123;</span><br><span class="line">    <span class="attr">esModules</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">umd</span>: &#123;</span><br><span class="line">      <span class="attr">global</span>: <span class="string">&#x27;y&#x27;</span>,</span><br><span class="line">      <span class="attr">externals</span>: &#123;</span><br><span class="line">        <span class="attr">react</span>: <span class="string">&#x27;React&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">webpack</span>: &#123;</span><br><span class="line">    <span class="attr">config</span>: <span class="string">&#x27;webpack.config.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>修改 <code>package.json</code> 文件，将启动命令改为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nwb serve-react-demo --config webpack.config.js&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li></ol><p>重启项目后，应该能够通过域名直接访问项目了<br>最后一步，我踩坑了好久才解决这个问题</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人主页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程调度的基本过程</title>
      <link href="/post/2e725c24.html"/>
      <url>/post/2e725c24.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程调度的基本过程"><a href="#进程调度的基本过程" class="headerlink" title="进程调度的基本过程"></a>进程调度的基本过程</h1><h2 id="一-什么是进程？"><a href="#一-什么是进程？" class="headerlink" title="一. 什么是进程？"></a>一. 什么是进程？</h2><p>进程是操作系统对正在运行的程序的抽象。可以将进程视为特定时刻程序的一次执行过程。在操作系统内部，进程是资源分配的基本单位。通过进程，操作系统可以有效地管理和调度系统中的各项任务，使多个任务可以在一个处理器上交替执行，从而实现并发和并行。</p><p><img src="https://image.nicebao.com/luntan/202308171218293.webp" alt="进程示意图"></p><h2 id="二-进程的组成与描述"><a href="#二-进程的组成与描述" class="headerlink" title="二. 进程的组成与描述"></a>二. 进程的组成与描述</h2><h3 id="1-进程由两部分组成：描述和组织。"><a href="#1-进程由两部分组成：描述和组织。" class="headerlink" title="1. 进程由两部分组成：描述和组织。"></a>1. 进程由两部分组成：描述和组织。</h3><h4 id="1-1-描述："><a href="#1-1-描述：" class="headerlink" title="1.1 描述："></a>1.1 描述：</h4><p>进程的属性被存储在进程控制块（PCB）中。PCB 可以被视为进程的档案，其中包含了关键信息，如进程ID、内存指针、文件描述符表等。</p><p>举个例子，想象你正在玩一个多人在线游戏。你是一个进程，而你的PCB就包含了你在游戏中的ID、当前所在的地图位置以及你的游戏资源状态。</p><h4 id="1-2-组织："><a href="#1-2-组织：" class="headerlink" title="1.2 组织："></a>1.2 组织：</h4><p>操作系统通过双向链表将多个PCB连接在一起，形成了就绪队列。就绪队列中存放了等待被调度执行的所有进程。当一个进程需要被执行时，操作系统会从就绪队列中选择一个合适的进程进行调度。</p><p>举个类比，把就绪队列想象成一个电影院的排队队伍。每个PCB就像一个电影观众，等待着进入放映厅（CPU）观看电影（执行任务）。</p><h3 id="2-PCB内部描述了进程的特征："><a href="#2-PCB内部描述了进程的特征：" class="headerlink" title="2. PCB内部描述了进程的特征："></a>2. PCB内部描述了进程的特征：</h3><h4 id="2-1-进程的特征"><a href="#2-1-进程的特征" class="headerlink" title="2.1 进程的特征"></a>2.1 进程的特征</h4><ol><li><p><strong>进程标识符（PID）：</strong> 类似于每个人的身份证号码，用于唯一标识一个进程。</p></li><li><p><strong>内存指针：</strong> 就像是你在地图上的位置标记，指示进程所占用的内存区域。</p></li><li><p><strong>文件描述符表：</strong> 类似于你的工具箱，包含进程持有的文件和其他资源，比如硬盘上的文件。</p></li><li><p><strong>进程调度相关属性：</strong></p><ul><li><strong>进程状态：</strong> 就绪状态（随时可执行）、运行状态（当前正在执行）、阻塞状态（无法立即执行，如IO密集操作）。</li><li><strong>优先级：</strong> 不同进程具有不同的优先级，操作系统根据优先级进行调度。就像不同等级的乘客在机场的登机顺序。</li><li><strong>上下文：</strong> 在进程切换时，需要保存当前进程的执行状态，以便下次恢复时可以继续执行。这包括CPU寄存器的值，类似于暂停游戏时记录的进度，以便以后继续。</li><li><strong>记账信息：</strong> 统计进程在CPU上占用的时间和执行的指令数量，影响下一阶段的调度决策。</li></ul></li></ol><h4 id="2-2-并行和并发"><a href="#2-2-并行和并发" class="headerlink" title="2.2 并行和并发"></a>2.2 并行和并发</h4><p>调度的目标是实现分时复用，使多个进程共享处理器的时间，从而提高系统的效率。并行和并发是两种实现这一目标的不同方式：</p><ul><li><strong>并行：</strong> 多个进程在不同的处理器核心上同时执行，就像多个厨师在不同的灶台上烹饪不同的菜肴。</li><li><strong>并发：</strong> 微观上，单个核心在同一时刻只能执行一个进程，但在不同进程之间快速切换执行，造成多个任务几乎同时运行的错觉。这由操作系统内核管理。</li></ul><h2 id="三-内存管理：虚拟地址空间"><a href="#三-内存管理：虚拟地址空间" class="headerlink" title="三. 内存管理：虚拟地址空间"></a>三. 内存管理：虚拟地址空间</h2><p>程序获取的内存地址实际上是虚拟地址，而非物理内存地址。虚拟地址是一种抽象，通过操作系统和硬件进行虚拟地址到物理地址的转换。</p><p>进程隔离引入了虚拟地址空间的概念，程序不再直接使用真实的物理地址。虚拟地址空间解决了进程间影响的问题，但也引入了新的挑战。进程需要进行数据交互时，需要通过进程间通信来实现。通信方式多种多样，核心思想是创建一个公共空间，用于数据交换。</p><p><img src="https://image.nicebao.com/luntan/202308171218437.webp" alt="虚拟地址空间示意图"></p><p><img src="https://image.nicebao.com/luntan/202308171218754.webp" alt="虚拟地址转换示意图"></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Thread类的基本用法笔记</title>
      <link href="/post/b3784eb8.html"/>
      <url>/post/b3784eb8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Thread类的基本用法笔记"><a href="#Thread类的基本用法笔记" class="headerlink" title="Thread类的基本用法笔记"></a>Thread类的基本用法笔记</h1><h2 id="一-线程创建"><a href="#一-线程创建" class="headerlink" title="一.线程创建"></a>一.线程创建</h2><h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类"></a>1.继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-匿名内部类"><a href="#3-匿名内部类" class="headerlink" title="3.匿名内部类"></a>3.匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;myThread&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用lambda表达式"><a href="#4-使用lambda表达式" class="headerlink" title="4.使用lambda表达式"></a>4.使用lambda表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;myThread&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-线程终止"><a href="#二-线程终止" class="headerlink" title="二.线程终止"></a>二.线程终止</h2><h3 id="1-使用自定义的标识符来终止线程"><a href="#1-使用自定义的标识符来终止线程" class="headerlink" title="1.使用自定义的标识符来终止线程"></a>1.使用自定义的标识符来终止线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTerminationExample1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 自定义标识符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">                <span class="comment">// 线程执行的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread terminated.&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟一段时间后停止线程</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        isRunning = <span class="literal">false</span>; <span class="comment">// 设置标识符来终止线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用interrupt-终止线程"><a href="#2-使用interrupt-终止线程" class="headerlink" title="2.使用interrupt() 终止线程"></a>2.使用interrupt() 终止线程</h3><h5 id="2-1理解线程中断"><a href="#2-1理解线程中断" class="headerlink" title="2.1理解线程中断"></a>2.1理解线程中断</h5><p>Java中的<code>Thread</code>类提供了一些更优雅的方法来操作线程的中断状态：</p><ul><li><code>void interrupt()</code>: 请求中断线程。</li><li><code>boolean isInterrupted()</code>: 检查线程的中断状态。（通常不会使用）</li><li><code>static boolean interrupted()</code>: 检查当前线程的中断状态，并清除中断状态。</li></ul><h4 id="2-2-检测中断状态"><a href="#2-2-检测中断状态" class="headerlink" title="2.2 检测中断状态"></a>2.2 检测中断状态</h4><p>在线程内部，可以使用<code>Thread.currentThread().isInterrupted()</code>来检查线程的中断状态，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">    <span class="comment">// 线程执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个循环中，线程会一直运行，直到中断状态变为<code>true</code>，即线程被请求中断。</p><h4 id="2-3处理InterruptedException"><a href="#2-3处理InterruptedException" class="headerlink" title="2.3处理InterruptedException"></a>2.3处理InterruptedException</h4><p>在某些情况下，线程可能会等待某些条件的发生，例如使用<code>Thread.sleep()</code>或<code>Object.wait()</code>。这些操作可能会抛出<code>InterruptedException</code>异常，因为其他线程调用了中断操作，希望中断当前线程的等待状态。</p><p>当捕获到<code>InterruptedException</code>时，通常的做法是在异常处理中重新设置线程的中断状态，以便线程能够正确地响应中断。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 在等待期间可能抛出InterruptedException</span></span><br><span class="line">    <span class="comment">// 处理等待逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">// 重新设置中断状态</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4示例代码"><a href="#2-4示例代码" class="headerlink" title="2.4示例代码"></a>2.4示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadInterruptExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程工作中&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟线程工作</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程收到中断请求&quot;</span>);</span><br><span class="line">                    Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断状态</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟一段时间后停止线程</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t线程终止&quot;</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-线程等待"><a href="#三-线程等待" class="headerlink" title="三.线程等待"></a>三.线程等待</h2><h3 id="1-join-方法"><a href="#1-join-方法" class="headerlink" title="1.join()方法"></a>1.join()方法</h3><h4 id="1-1理解join方法"><a href="#1-1理解join方法" class="headerlink" title="1.1理解join方法"></a>1.1理解join方法</h4><ul><li><code>void join()</code>: 等待线程结束。</li><li><code>void join(long millis)</code>: 等待线程结束，最多等待millis毫秒。</li><li><code>void join(long millis, int nanos)</code>: 等待线程结束，最多等待millis毫秒 + nanos纳秒。</li></ul><h4 id="1-2使用join方法"><a href="#1-2使用join方法" class="headerlink" title="1.2使用join方法"></a>1.2使用join方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadJoinExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程运行中.&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;主方法运行中.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-线程休眠"><a href="#四-线程休眠" class="headerlink" title="四.线程休眠"></a>四.线程休眠</h2><h3 id="1-sleep-方法"><a href="#1-sleep-方法" class="headerlink" title="1.sleep()方法"></a>1.sleep()方法</h3><h4 id="1-1方法"><a href="#1-1方法" class="headerlink" title="1.1方法"></a>1.1方法</h4><ul><li><code>public static void sleep(long millis) throws InterruptedException</code>: 休眠当前线程millis毫秒。</li><li><code>public static void sleep(long millis, int nanos) throws InterruptedException</code>: 更高精度的休眠。</li></ul><h4 id="1-2示例-结果"><a href="#1-2示例-结果" class="headerlink" title="1.2示例&#x2F;结果"></a>1.2示例&#x2F;结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSleepExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(end - begin);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5000</span></span><br></pre></td></tr></table></figure><h3 id="2-TimeUtil休眠"><a href="#2-TimeUtil休眠" class="headerlink" title="2.TimeUtil休眠"></a>2.TimeUtil休眠</h3><h4 id="2-1方法"><a href="#2-1方法" class="headerlink" title="2.1方法"></a>2.1方法</h4><p><code>TimeUnit.DAYS.sleep(1);</code> &#x2F;&#x2F; 天<br><code>TimeUnit.HOURS.sleep(1);</code> &#x2F;&#x2F; 小时<br><code>TimeUnit.MINUTES.sleep(1);</code> &#x2F;&#x2F; 分<br><code>TimeUnit.SECONDS.sleep(1);</code> &#x2F;&#x2F; 秒<br><code>TimeUnit.MILLISECONDS.sleep(1000);</code> &#x2F;&#x2F; 毫秒<br><code>TimeUnit.MICROSECONDS.sleep(1000);</code> &#x2F;&#x2F; 微秒<br><code>TimeUnit.NANOSECONDS.sleep(1000);</code> &#x2F;&#x2F; 纳秒</p><h4 id="1-2代码示例"><a href="#1-2代码示例" class="headerlink" title="1.2代码示例"></a>1.2代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTimeUnitExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">1000</span>); <span class="comment">// 休眠1微秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(end - begin);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-获取线程实例"><a href="#五-获取线程实例" class="headerlink" title="五.获取线程实例"></a>五.获取线程实例</h2><h3 id="1-currentThread-方法"><a href="#1-currentThread-方法" class="headerlink" title="1.currentThread()方法"></a>1.currentThread()方法</h3><h4 id="1-1方法-1"><a href="#1-1方法-1" class="headerlink" title="1.1方法"></a>1.1方法</h4><p><code>public static Thread currentThread();</code> 返回当前对象的引用</p><h4 id="1-2代码示例-1"><a href="#1-2代码示例-1" class="headerlink" title="1.2代码示例"></a>1.2代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadInstanceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">&quot;Current thread: &quot;</span> + currentThread.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程状态及状态转换条件</title>
      <link href="/post/2daabb61.html"/>
      <url>/post/2daabb61.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程状态及状态转换条件"><a href="#线程状态及状态转换条件" class="headerlink" title="线程状态及状态转换条件"></a>线程状态及状态转换条件</h1><h3 id="1-NEW（新建状态）"><a href="#1-NEW（新建状态）" class="headerlink" title="1. NEW（新建状态）"></a><strong>1. NEW（新建状态）</strong></h3><p>这是线程刚被创建但尚未启动的状态。在此状态下，虽然线程对象已经存在，但在调用<code>.start()</code>方法之前，线程不会执行实际任务。当调用<code>.start()</code>方法后，线程会进入到<code>RUNNABLE</code>状态。</p><h3 id="2-TERMINATED（终止状态）"><a href="#2-TERMINATED（终止状态）" class="headerlink" title="2. TERMINATED（终止状态）"></a><strong>2. TERMINATED（终止状态）</strong></h3><p>在线程的任务执行完成、抛出异常或者调用<code>.stop()</code>方法后，线程进入终止状态。在这种状态下，虽然线程对象仍然存在，但是内核中的线程已经结束，不再执行任务。</p><h3 id="3-RUNNABLE（运行状态）"><a href="#3-RUNNABLE（运行状态）" class="headerlink" title="3. RUNNABLE（运行状态）"></a><strong>3. RUNNABLE（运行状态）</strong></h3><p>线程在 CPU 上执行，或者在队列中等待 CPU 时间时，处于 <code>RUNNABLE</code>状态。这是线程执行任务的活跃状态。</p><h3 id="4-TIME-WAITING（计时等待状态）"><a href="#4-TIME-WAITING（计时等待状态）" class="headerlink" title="4. TIME_WAITING（计时等待状态）"></a><strong>4. TIME_WAITING（计时等待状态）</strong></h3><p>有时候，线程需要在一段时间内暂时阻塞自己，例如通过调用<code>Thread.sleep()</code>方法。进入<code>TIME_WAITING</code>状态后，线程会等待指定的时间后恢复到<code>RUNNABLE</code>状态，或者当等待时间结束后，自动切换到<code>RUNNABLE</code>状态。这种状态对于需要暂停一段时间或进行定时任务的情况很有用。</p><h3 id="5-WAITING（等待状态）"><a href="#5-WAITING（等待状态）" class="headerlink" title="5. WAITING（等待状态）"></a><strong>5. WAITING（等待状态）</strong></h3><p>当线程在等待某些条件满足时，会进入<code>WAITING</code>状态。通常通过调用<code>Object.wait()</code>方法实现。在这种状态下，线程会释放其持有的锁，并暂停执行，直到其他线程通知它可以继续执行。</p><h3 id="6-BLOCKED（阻塞状态）"><a href="#6-BLOCKED（阻塞状态）" class="headerlink" title="6. BLOCKED（阻塞状态）"></a><strong>6. BLOCKED（阻塞状态）</strong></h3><p>线程在某些情况下可能被阻塞，例如等待I&#x2F;O操作完成或等待获取某个对象的锁。当线程进入<code>BLOCKED</code>状态时，它会暂时停止执行，直到满足解除阻塞的条件为止。</p><h3 id="状态切换条件总结"><a href="#状态切换条件总结" class="headerlink" title="状态切换条件总结"></a><strong>状态切换条件总结</strong></h3><ol><li><code>NEW</code> -&gt; <code>RUNNABLE</code>：调用线程的<code>.start()</code>方法。</li><li><code>RUNNABLE</code> -&gt; <code>BLOCKED</code>：竞争锁失败，被其他线程占用锁资源。</li><li><code>RUNNABLE</code> -&gt; <code>WAITING</code>：调用了<code>Object.wait()</code>等方法，主动释放锁，等待其他线程通知。</li><li><code>RUNNABLE</code> -&gt; <code>TIME_WAITING</code>：调用<code>Thread.sleep()</code>等方法，暂时阻塞自己一段时间。</li><li><code>RUNNABLE</code> -&gt; <code>TERMINATED</code>：线程的任务执行完成。</li><li><code>BLOCKED</code> -&gt; <code>RUNNABLE</code>：成功获取到锁资源。</li><li><code>WAITING</code> -&gt; <code>RUNNABLE</code>：被其他线程通知，等待结束。</li><li><code>TIME_WAITING</code> -&gt; <code>RUNNABLE</code>：等待时间结束。</li><li><code>WAITING</code>、<code>TIME_WAITING</code> -&gt; <code>TERMINATED</code>：调用<code>Thread.stop()</code>方法，或线程被中断。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>探讨Runnable与Thread的区别</title>
      <link href="/post/aac4d9fe.html"/>
      <url>/post/aac4d9fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="探讨Runnable与Thread的区别"><a href="#探讨Runnable与Thread的区别" class="headerlink" title="探讨Runnable与Thread的区别"></a>探讨Runnable与Thread的区别</h1><h2 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h2><p>在并发编程领域，Java提供了多种方式来实现多线程，其中<code>Runnable</code>接口和<code>Thread</code>类是常见的实现方式。虽然它们都可以用于多线程任务的执行，但是它们之间存在着一些关键的区别。</p><h2 id="二-创建线程的步骤"><a href="#二-创建线程的步骤" class="headerlink" title="二.创建线程的步骤"></a>二.创建线程的步骤</h2><p>让我们先来看看如何使用<code>Runnable</code>和<code>Thread</code>创建线程。这将帮助我们更好地理解它们的区别。</p><h3 id="1-使用Runnable接口创建线程"><a href="#1-使用Runnable接口创建线程" class="headerlink" title="1.使用Runnable接口创建线程"></a>1.使用Runnable接口创建线程</h3><p>通过实现<code>Runnable</code>接口，我们可以将线程的任务逻辑与线程控制分离。以下是使用<code>Runnable</code>的创建线程步骤：</p><ol><li><strong>定义任务类</strong>：创建一个实现了<code>Runnable</code>接口的类，重写<code>run()</code>方法，将线程的具体任务逻辑放在这个方法中。</li><li><strong>创建线程实例</strong>：实例化一个<code>Thread</code>对象，将前面定义的任务类实例传递给<code>Thread</code>构造函数。</li><li><strong>启动线程</strong>：调用<code>Thread</code>实例的<code>start()</code>方法来启动线程，它会自动调用任务类的<code>run()</code>方法。</li></ol><h4 id="1-1示例代码如下："><a href="#1-1示例代码如下：" class="headerlink" title="1.1示例代码如下："></a>1.1示例代码如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程的具体任务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用Thread类创建线程"><a href="#2-使用Thread类创建线程" class="headerlink" title="2.使用Thread类创建线程"></a>2.使用Thread类创建线程</h3><p>直接继承<code>Thread</code>类也是创建线程的一种方式。以下是使用<code>Thread</code>的创建线程步骤：</p><ol><li><strong>继承Thread类</strong>：创建一个继承自<code>Thread</code>的子类，在子类中重写<code>run()</code>方法，将线程的任务逻辑放在这个方法中。</li><li><strong>创建线程实例</strong>：实例化子类对象。</li><li><strong>启动线程</strong>：调用子类对象的<code>start()</code>方法来启动线程，它会自动调用重写的<code>run()</code>方法。</li></ol><h4 id="2-1示例代码如下："><a href="#2-1示例代码如下：" class="headerlink" title="2.1示例代码如下："></a>2.1示例代码如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程的具体任务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-解耦合的设计思想"><a href="#三-解耦合的设计思想" class="headerlink" title="三.解耦合的设计思想"></a>三.解耦合的设计思想</h2><p><code>Runnable</code>接口体现了一种重要的设计思想，即解耦合。解耦合是指将系统的不同部分分离开来，使它们能够独立地进行修改、维护和扩展，从而提高系统的灵活性和可维护性。</p><h3 id="1-为什么要考虑解耦合？"><a href="#1-为什么要考虑解耦合？" class="headerlink" title="1.为什么要考虑解耦合？"></a>1.为什么要考虑解耦合？</h3><p>让我们用一个生活中的例子来说明解耦合的重要性。假设你是一家餐厅的经理，雇佣了多名大厨来烹饪食物。每个大厨都有自己的特长和专业领域。当顾客点菜时，你需要将任务分配给不同的大厨来准备。在这个情景中，你需要解耦合任务（菜品准备）和执行者（大厨），以便根据不同的情况进行灵活分配。</p><h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h3><p>假设你正在开发一个多线程的文件下载器，其中不同的下载任务可以并行执行。使用<code>Runnable</code>接口可以轻松地定义下载任务，并且你可以更改任务的优先级、添加新任务等，而不必修改整个下载器的逻辑。这种灵活性使你能够更容易地适应未来的需求变化。</p><h2 id="四-区别与对比"><a href="#四-区别与对比" class="headerlink" title="四.区别与对比"></a>四.区别与对比</h2><p>下表详细列出了<code>Runnable</code>接口和<code>Thread</code>类之间的关键区别：</p><table><thead><tr><th></th><th><strong>Runnable</strong></th><th><strong>Thread</strong></th></tr></thead><tbody><tr><td>类型</td><td>接口</td><td>类</td></tr><tr><td>方法</td><td><code>run()</code> 方法</td><td>可重写的 <code>run()</code> 方法</td></tr><tr><td>继承关系</td><td>无需继承其他类</td><td>继承Thread类</td></tr><tr><td>资源利用</td><td>多个线程可共享一个任务实例</td><td>每个线程都有自己的任务实例，不能直接共享实例变量（可以使用静态变量或共享对象锁实现共享）</td></tr><tr><td>多继承</td><td>可在需要时继续继承其他类</td><td>不支持多重继承</td></tr><tr><td>灵活性</td><td>更灵活，任务逻辑与线程控制分离</td><td>较少灵活，任务与线程控制紧密耦合</td></tr><tr><td>线程数量控制</td><td>可通过创建多个线程执行同一任务</td><td>每个线程对应一个独立执行单元</td></tr></tbody></table><h2 id="五-选择适合的方式"><a href="#五-选择适合的方式" class="headerlink" title="五. 选择适合的方式"></a>五. 选择适合的方式</h2><p>选择使用<code>Runnable</code>还是<code>Thread</code>取决于项目需求和设计目标。如果你希望更好地解耦合任务和线程控制，从而提高代码的可维护性和扩展性，推荐使用<code>Runnable</code>接口。这种方式能够更清晰地分离任务逻辑，使代码结构更加模块化。</p><p>另一方面，如果你需要更简洁的方式来创建线程，并且对任务与线程的耦合度要求不高，可以使用继承<code>Thread</code>类的方法。但要注意，由于Java不支持多重继承，这可能会限制你在继承其他类时的选择。</p><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六.总结"></a>六.总结</h2><p>通过本文的探讨，我们深入了解了<code>Runnable</code>接口和<code>Thread</code>类之间的区别。无论你选择哪种方式，理解它们的优势和劣势，以及何时使用其中之一，都是编写高质量多线程代码的关键。在设计多线程系统时，合理选择适当的实现方式将有助于提高程序性能、可维护性和灵活性</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程的区别</title>
      <link href="/post/7202bd7a.html"/>
      <url>/post/7202bd7a.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><h2 id="一-什么是进程和线程"><a href="#一-什么是进程和线程" class="headerlink" title="一.什么是进程和线程"></a>一.什么是进程和线程</h2><h3 id="1-首先举个栗子："><a href="#1-首先举个栗子：" class="headerlink" title="1. 首先举个栗子："></a>1. 首先举个栗子：</h3><p>比如我有一个木材加工厂，现在生意不错，我需要增加一些产能，那么我现在就有两种选择</p><p>①新开设一座工厂→进程</p><p>②新加一条生产线→线程</p><p>我们这里新开一座工厂，就类似创建一个新的进程，我们的场地，木材，工人和上一个工厂没有太多的联系，抗风险能力也随之提升。</p><p>而我们新加一条生产线呢，就类似创建了一个新的进程，和其他进程共享同一块地盘（内存空间），原材料（资源），抗风险能力也随之减弱（一个线程的崩溃可能会影响同一进程中的其他线程）。</p><h3 id="2-再举个栗子："><a href="#2-再举个栗子：" class="headerlink" title="2.再举个栗子："></a>2.再举个栗子：</h3><p>线程在进程下行进（单纯的车厢无法运行）</p><p>一个进程可以包含多个线程（一辆火车可以有多个车厢）</p><p>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</p><p>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</p><p>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</p><p>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢与前一节产生断裂，将影响后面的所有车厢）</p><p>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</p><p>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”</p><p>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</p><h3 id="3-看一下定义："><a href="#3-看一下定义：" class="headerlink" title="3.看一下定义："></a>3.看一下定义：</h3><p><img src="https://image.nicebao.com/luntan/202308121936616.webp" alt="image-20230812193657000"></p><p><strong>进程</strong>（Process）是计算机中的程序关于某<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%9B%86/4745883?fromModule=lemma_inlink">数据集</a>合上的一次运行活动，是系统进行<a href="https://baike.baidu.com/item/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D/2944359?fromModule=lemma_inlink">资源分配</a>的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D/10189558?fromModule=lemma_inlink">基本单位</a>，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体</p><p><strong>线程</strong>（thread）是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>能够进行运算<a href="https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6?fromModule=lemma_inlink">调度</a>的最小单位。它被包含在<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">进程</a>之中，是<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">进程</a>中的实际运作单位。一条线程指的是<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">进程</a>中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及<a href="https://baike.baidu.com/item/SunOS?fromModule=lemma_inlink">SunOS</a>中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p><h2 id="二-进程与线程的联系和区别"><a href="#二-进程与线程的联系和区别" class="headerlink" title="二.进程与线程的联系和区别"></a>二.进程与线程的联系和区别</h2><table><thead><tr><th align="center"></th><th align="center"><strong>进程</strong></th><th align="center"><strong>线程</strong></th></tr></thead><tbody><tr><td align="center"><strong>定义</strong></td><td align="center">资源分配的最小单位</td><td align="center">程序执行的最小单位</td></tr><tr><td align="center"><strong>资源分配</strong></td><td align="center">每个进程都有独立的内存空间和资源，不同进程之间的通信需要消耗更多的资源</td><td align="center">线程共享相同进程的内存空间和资源，因此线程间通信更加高效。</td></tr><tr><td align="center"><strong>创建与销毁</strong></td><td align="center">创建新进程需要较多的系统资源和时间，进程的创建和销毁相对较慢</td><td align="center">创建和销毁线程相对较快，因为它们共享进程的资源，所需的开销较小</td></tr><tr><td align="center"><strong>稳定性</strong></td><td align="center">进程之间具有隔离性，某个进程崩溃不会影响其它进程</td><td align="center">一个线程的崩溃可能会影响同一进程中的其他线程</td></tr></tbody></table><table><thead><tr><th align="center"></th><th align="center"><strong>进程和线程的联系</strong></th></tr></thead><tbody><tr><td align="center"><strong>同一进程内</strong></td><td align="center">进程可以包含多个线程，这些线程共享相同的内存空间和资源，可以更加高效地协同工作</td></tr><tr><td align="center"><strong>并发执行</strong></td><td align="center">进程和线程都可以实现并发执行，提高系统的效率和响应速度。</td></tr><tr><td align="center"><strong>通信与同步</strong></td><td align="center">无论是进程还是线程，都需要进行通信和同步来共享数据和协调任务。进程间的通信较为复杂，而线程间通信相对简单。</td></tr><tr><td align="center"><strong>资源共享</strong></td><td align="center">在多核处理器上，多个线程可以同时运行在不同的核心上，从而更好地利用硬件资源。</td></tr><tr><td align="center"><strong>系统开销</strong></td><td align="center">线程共享进程的资源，创建和销毁线程的开销较小，适用于需要频繁创建销毁任务的情况。</td></tr></tbody></table><p>注：如果一个进程中只有一个线程，那么线程结束代表着进程结束</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>和大家分享一款软件PicList</title>
      <link href="/post/3c7c81e9.html"/>
      <url>/post/3c7c81e9.html</url>
      
        <content type="html"><![CDATA[<h1 id="和大家分享一款软件PicList"><a href="#和大家分享一款软件PicList" class="headerlink" title="和大家分享一款软件PicList"></a>和大家分享一款软件PicList</h1><p>首先放上<a href="https://github.com/Kuingsmile/PicList">github链接</a></p><p>今天我在想有没有什么办法，在使用PicGo上传图片时能不使用图床的在线处理，自动压缩成webp格式，偶然间发现了这款软件。</p><p>对我来说，PicList增加的这两个功能最为实用</p><ul><li><p>相册中可同步删除云端图片，同时新增了高级搜索和排序，批量修改URL等功能</p></li><li><p>内置水印添加、图片压缩、图片缩放、图片旋转和图片格式转换等功能，支持自定义配置，且可以通过CLI命令行调用</p></li></ul><p>并且，Typora 1.6以上的版本完美支持这款软件，1.6以下也可以通过其他方法使用。</p><p>提示：typora配置自动上传后可能会提示failed to fetch错误，如果端口没有问题，那么可以尝试在PicList中，关闭一下sever服务再打开，没准可以解决。</p><p>这个方法也同样适用于PicGo中提示failed to fetch的问题。</p><p><img src="https://tuchuang.33mc.cn/luntan/202307281513167.webp" alt="image-20230728151333065"></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何创建自己的域名邮箱？</title>
      <link href="/post/f445dfa9.html"/>
      <url>/post/f445dfa9.html</url>
      
        <content type="html"><![CDATA[<p>目前我尝试了腾讯企业邮箱，qq邮箱绑定域名，网易免费企业邮，阿里企业邮这四种方式。<br>腾讯企业邮好像没有免费版本了（也可能是我打开方式不对），qq邮箱现在也无法绑定域名。<br>所以在我尝试的四种方法中，只有网易免费邮箱和阿里企业邮箱目前还可以免费使用。</p><hr><p>接下来，我将介绍如何通过阿里企业邮箱来创建我们自己的域名邮箱。<br>首先登陆阿里云，搜索企业邮箱免费版，然后进行购买。<br><a href="https://common-buy.aliyun.com/?spm=5176.21213303.J_6704733920.7.f9c353c9NrNf5G&commodityCode=alimail&specCode=lx_18482&request=%7B%22ord_time%22:%221:Year%22,%22account_num%22:%225%22%7D#/buy">快捷购买链接</a></p><p><img src="https://image.nicebao.com/luntan/20230728_115025.webp"></p><p>这里推荐购买五年套餐。<br>购买后，我们从阿里云控制台进入企业邮箱管理页面。</p><p><a href="https://alimail.console.aliyun.com/?userCode=s6usmdta#eyJ2YWx1ZSI6InByb2R1Y3RMaXN0In0=">控制台快捷链接</a><br><img src="https://image.nicebao.com/luntan/20230728_45261.webp"><br><img src="https://image.nicebao.com/luntan/20230728_25643.webp"><br><img src="https://image.nicebao.com/luntan/20230728_24700.webp"></p><p>登陆后，我们需要到自己域名的控制台设置解析记录，然后修改默认密码。<br>操作完成后，我们就可以登陆我们的邮箱了！<br>密码是我们刚刚自己重置的密码，账户就是控制台给我们分配的管理员账户。<br><a href="https://qiye.aliyun.com/">登陆邮箱</a></p><p><img src="https://image.nicebao.com/luntan/1690520193824.jpg"></p><p>登陆阿里云企业邮箱后，我们就可以点击新建账号，在里面新建我们想要的域名邮箱了，后续的发信收信，只需要用我们自己新建的账号登陆阿里云企业邮箱就可以了，不需要在进入阿里云控制台进行操作。<br>至此教程完毕。</p><hr><p>关于免费版企业邮箱是否会到期的问题，阿里云给出了如下答复。<br>免费版企业邮箱产品，目前没有收费计划，系统显示到期时间默认为1年，到期后会自动延长。如有变动，会提前在阿里云官网进行公告通知。</p><p>另外，请注意免费邮箱如果申请后7天内用户邮箱域名解析未设置生效，系统将收回此邮箱服务，再次使用此邮箱需要重新申请。</p><p>同时，若您的阿里云账号未实名认证，会导致免费企业邮箱自动延期失败、邮箱过期。请您在免费邮箱到期30天内，尽快完成阿里云账号实名认证，避免到期30天后自动释放数据无法找回。在完成实名认证后，您的免费邮箱状态将自动恢复正常，系统会自动延长免费周期。</p><p><img src="https://image.nicebao.com/luntan/1690520369684.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名邮箱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找为什么不能使用(left+right)/2？</title>
      <link href="/post/b71ae0d.html"/>
      <url>/post/b71ae0d.html</url>
      
        <content type="html"><![CDATA[<p>刚刚在刷力扣时，刷到了一个简单地二分查找问题。<br>但当我提交时发现，超出了时间限制。<br>经过检查发现是中值出现了问题，mid &#x3D; (left+right)&#x2F;2;</p><hr><p>若使用(left+right)&#x2F;2，因为java中int数据类型是32位的，数值超过32位就会被反转。eg：2147483647+1 &#x3D; -2147483648。<br>所以，我们不应使用此方法。而是应该使用left + (right - left)&#x2F;2 &lt;&#x3D; right<br>因为根据定义得left &lt; right<br>所以，right - left &gt; 0且 &lt;&#x3D; right。并且left + (right - left) &#x3D; right<br>因此，left + (right - left)&#x2F;2 &lt;&#x3D; right;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Forward declaration of guess API.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  num   your guess</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>      -1 if num is higher than the picked number</span></span><br><span class="line"><span class="comment"> *      1 if num is lower than the picked number</span></span><br><span class="line"><span class="comment"> *               otherwise return 0</span></span><br><span class="line"><span class="comment"> * int guess(int num);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">GuessGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">guessNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span> &lt;= right;</span><br><span class="line">            <span class="comment">//int mid = (left+right)/2;</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> guess(mid);</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(result == -<span class="number">1</span>)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(result == <span class="number">1</span>)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国家海洋博物馆之旅</title>
      <link href="/post/c496ef79.html"/>
      <url>/post/c496ef79.html</url>
      
        <content type="html"><![CDATA[<p>高二那时候，地理老师就向我们推荐了国家海洋博物馆，但毕业我才有幸踏上这场穿越海洋时光的奇妙之旅。</p><p>让我印象最深刻的是在场馆出口的那句话：“我们人类居住的这个蓝色星球，不仅仅是被陆地分割成了各个孤岛，而是被广袤的海洋连结成了命运共同体，各国人民安危与共。”</p><p><img src="https://image.nicebao.com/luntan/blog202320230721_4766886.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_6525790.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_5391039.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_5249557.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_5120609.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4644679.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4693373.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4759893.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4944902.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4607985.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4566931.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4529512.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4525218.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4165083.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4258914.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4417696.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4450048.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4049673.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_3812686.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_3615769.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博物馆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周恩来邓颖超纪念馆</title>
      <link href="/post/f5edf104.html"/>
      <url>/post/f5edf104.html</url>
      
        <content type="html"><![CDATA[<p>周恩来、邓颖超纪念馆位于天津水上公园北侧，占地6公顷，建筑面积7150平方米，是一座传统文化和现代文化相结和的新型文化设施。展厅包括瞻仰厅、生平厅、情怀厅，还设有影视厅、多功能厅、贵宾厅、研究中心、文物库，集文物展览、群众教育和学术研究等功能为一体。</p><span id="more"></span><p><img src="https://image.nicebao.com/luntan/blog202320230721_4717563.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4792646.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4860260.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_5052386.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_5175707.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_5262379.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_6284900.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_6389038.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_6891000.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_7591562.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纪念馆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易云美化教程</title>
      <link href="/post/b246be57.html"/>
      <url>/post/b246be57.html</url>
      
        <content type="html"><![CDATA[<h1 id="网易云究极美化"><a href="#网易云究极美化" class="headerlink" title="网易云究极美化"></a>网易云究极美化</h1><p>众所周知网易云win版客户端的UI和手机端没有一点可比性。</p><p>因此，我搭建了一个自用的网页版的网易云，可是相对的缺点是，这里只能显示我喜欢的歌曲，如果我想要听别的歌，这里是没办法做到的，还是要去网易云客户端，并且没办法听VIP歌曲。</p><p><img src="https://image.nicebao.com/luntan/f117f22c2653a5e17d48a85be65ed306.webp" alt="image-20240111233757302"></p><p>但今天，我找到了一款网易云客户端美化插件</p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>我的最终美化效果如图所示，还有非常多的主题和插件可以随意调配</p><p><img src="https://image.nicebao.com/luntan/cb682c9d65720ca99b20839f198d9756.webp" alt="image-20240111234945245"></p><p><img src="https://image.nicebao.com/luntan/b1e86ae75f16b65c14ec6509c04694e8.webp" alt="image-20240111235017820"></p><p><img src="https://image.nicebao.com/luntan/deeae924de3ad54153669d0d58d2558c.webp" alt="image-20240111235114093"></p><p><img src="https://image.nicebao.com/luntan/90d8cb2fb6c70c5d2a13c392678a8bd7.webp" alt="image-20240111235243166"></p><p><img src="https://image.nicebao.com/luntan/72a76ec41846ea2bd2026389319cfa97.webp" alt="image-20240111235401816"></p><h3 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h3><p>首先下载一键注入程序：<a href="https://github.com/MicroCBer/BetterNCM-Installer/releases/tag/1.1.1">Release 1.1.1 · MicroCBer&#x2F;BetterNCM-Installer (github.com)</a></p><p>下载最新的exe程序即可。</p><p><img src="https://image.nicebao.com/luntan/b2bcd0066e0dda486fb7502cb732b0cf.webp" alt="image-20240111235653793"></p><p>下载好打开点击安装即可，然后打开网易云，查看右上角有没有多出来插件图标</p><p><img src="https://image.nicebao.com/luntan/6d72771aef35c7edad00a8e5937cca49.webp" alt="image-20240111235841910"></p><p>出现及证明安装成功，点击插件图标，若没有任何内容就点击一下重载，就会出现plugingMarking插件市场，接下来在市场中选择喜欢的插件&#x2F;主题下载即可。</p><p>给大家看一下我的已安装内容，如果大家喜欢我上面的成品界面，可以仿照我的进行修改</p><p><img src="https://image.nicebao.com/luntan/ab6fa005b9c5a5fbe46cce0ce31a27a5.webp" alt="image-20240112000147894"></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美化 </tag>
            
            <tag> 网易云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大青山野生动物园</title>
      <link href="/post/83409c6a.html"/>
      <url>/post/83409c6a.html</url>
      
        <content type="html"><![CDATA[<p>学生票15，逛一次动物园，爬一次山，太值了！<br>总体占地面积很大，动物很全。<br>唯一批评的是动物园的熊猫，好像知道自己是国宝，到十点多才出来营业。<br>一个叫仨儿，一个叫茜茜（xī xī)，名字起的也是很独特</p><p><img src="https://image.nicebao.com/luntan/blog202320230721_2077882.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_2193712.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_2298068.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_2319980.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_2418810.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4217580.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4894243.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_5947078.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_7017390.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_1223221.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_1487189.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_1632508.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_1683451.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_1837242.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_1901708.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_1974038.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动物园 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>夜爬大青山</title>
      <link href="/post/4e65b09f.html"/>
      <url>/post/4e65b09f.html</url>
      
        <content type="html"><![CDATA[<h1 id="夜爬大青山：一场壮丽的征程"><a href="#夜爬大青山：一场壮丽的征程" class="headerlink" title="夜爬大青山：一场壮丽的征程"></a>夜爬大青山：一场壮丽的征程</h1><p><em>初尝AI写作——本文章部分由chatgpt 3.5生成</em></p><p>夜晚，是一个神秘而充满魅力的时刻。而在这个夜晚，我决定展开一场与大自然的亲密接触之旅。主题是夜爬大青山，这个位于内蒙古自治区呼和浩特市的壮美山脉。十点半，我和一群好友出发，开始了这段难忘的旅程。</p><p>为了提前给自己充电，我们先去了电影院看了一场电影。在欢声笑语中度过了一个愉快的时光后，我们决定到外面逛逛，享受夜晚的宁静。大约到了凌晨一点，我的一个同学开车来接我，我们一起前往大青山。途中，我们看到很多大学生骑着共享单车朝着同一个目的地前进，他们也是为了迎接这场壮丽的夜爬行动。</p><p>终于，我们来到了大青山健身步道。从车上下来，我立刻感受到了山夜的清凉。步道上已经有一些爱好者在准备登顶，他们或是悠闲地散步，或是沉浸在与自然的对话中。我感到一种与众不同的兴奋，因为这是我第一次尝试夜爬山。</p><p>夜色下的大青山散发着一种神秘而壮美的氛围。随着步道逐渐攀升，我们穿行在茂密的树林中，只听见自然的声音，远离了城市的喧嚣。星空在头顶闪烁，伴随着微弱的月光，我们稳步前行。</p><p>登顶的路途并不容易，但每一步都让我更加充实和满足。我的同学和我互相鼓励着，不断前行。我们感受到了身体的挑战，也领略到了大自然的力量。而在攀爬的过程中，我们看到了一些野生动物的痕迹，仿佛它们也在这片黑暗中与我们共舞。</p><p>终于，当夜空开始透露微光时，我们知道我们即将登顶。心中涌起一股难以言喻的激动，一种胜利的喜悦。三点钟，我们站在了大青山的巅峰，俯瞰着一片静谧的夜景。城市的灯光在远方闪烁，给予我们一种安慰和温暖。</p><p>夜爬大青山不仅仅是一次身体上的挑战，更是一次心灵的洗礼。站在山顶，我感到自己与大自然融为一体。那一刻，我感受到了无穷的力量和勇气，也更加珍惜和尊重这个美丽而脆弱的世界。</p><p>回顾这段旅程，我意识到自己在这次夜爬行动中获得了更多。我不仅仅攀登了山峰，也拓宽了自己的视野，结识了志同道合的伙伴，体验了大自然的神奇。而夜爬大青山也教会了我勇敢面对未知和挑战，相信自己的能力，并与自然和谐相处。</p><p>夜爬大青山，是一场奇妙的冒险之旅。这次旅行不仅让我欣赏到大自然的壮丽，也让我深深地触摸到内心的自由和坚毅。我相信，这段回忆将永远留在我心中，成为我成长和勇往直前的动力。</p><p><img src="https://image.nicebao.com/luntan/blog202320230721_685823.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_4576317.webp"><br><img src="https://image.nicebao.com/luntan/blog202320230721_6572386.webp"><br><img src="https://image.nicebao.com/luntan/blog2023file_02.webp"><br><img src="https://image.nicebao.com/luntan/blog2023file_03.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
